\section{Sistemi tipov}
\label{sec:sistemi-tipov}

% Kratek opis sistemov tipov
Sistemi tipov formalno definirajo pravila za določanje podatkovnega tipa poljubnega  izraza v programu. Poleg tega postavljajo omejitve, ki jih morajo vsi izrazi v programu izpolnjevati. Med njimi določijo katere operacije se lahko izvajajo nad izrazi z določenimi tipi in kakšnega tipa je izračunan rezultat. Tipični primer tovrstnih pravil je, da se aritmetične operacije, kot sta seštevanje in množenje, lahko izvajajo le nad numeričnimi tipi, medtem ko je seštevanje nizov in števil prepovedano.

Glede na način preverjanja tipov, ločimo statično in dinamično tipiziranje. Pri jezikih s statičnim tipiziranjem (angl. static typing) se podatkovni tipi izpeljejo oziroma izračunajo med prevajanjem, medtem ko se pri dinamičnem tipiziranju (angl. dynamic typing) preverjanje tipov izvaja med samim izvajanjem programa. Tako je pri statično tipiziranih jezikih, kot sta Java in Haskell, zagotovljeno, da se napake, povezane z nezdružljivostjo tipov, odkrijejo že med prevajanjem in ne med izvajanjem programa. Na drugi strani so jeziki z dinamičnim tipiziranjem, kot sta Python in JavaScript, podvrženi večjemu tveganju za napake med izvajanjem.

% STG ni tipiziran (Haskell pa je)
V poglavju \ref{ch:stg} smo lahko videli, da STG jezik ne vključuje preverjanja tipov, vendar to ne pomeni, da ni tipiziran. Podatkovni tipi so namreč izpeljani in preverjeni pred prevajanjem Haskella v STG. Izrek o varnosti sistemov tipov Haskella zagotavlja, da \textit{med izvajanjem} STG jezika z redukcijo grafa ne bo prišlo do napak, povezanih z nezdružljivostjo tipov.

% Na kratko o izpeljavi / preverjanju tipov
Pri izpeljavi oziroma preverjanju tipov, v kontekstu $\Gamma$ hranimo predpostavke o tipih spremenljivk, na katere smo že naleteli. Te predpostavke pomagajo pri določitvi tipov kompleksnejših izrazov in funkcij, saj lahko z uporabo že znanih tipov preverjamo in izpeljujemo tipe novih izrazov. Na ta način lahko v vsakem koraku preverimo, ali so tipi skladni s pravili sistema tipov.

% Substrukturni sistemi tipov
Večina programskih jezikov ima običajno neomejen (angl. unrestricted) sistem tipov, ki omogoča, da lahko do spremenljivk dostopamo poljubno mnogokrat in v poljubnem vrstnem redu. To je zagotovljeno s pomočjo treh strukturnih lastnosti:
\begin{itemize}
    \itemsep 0em
    \item \komentar{\textit{zamenjava}} (angl. exchange) zagotavlja, da vrstni red spremenljivk v kontekstu tipov ni pomemben. Če je preverjanje tipov uspešno v nekem kontekstu $\Gamma$, potem bo uspešno tudi v kateremkoli drugem kontekstu, ki je sestavljen kot permutacija predpostavk iz $\Gamma$.
    \item \komentar{\textit{oslabitev}} (angl. weakening) zagotavlja, da se lahko, kljub dodajanju neuporabnih predpostavk v kontekst tipov, izrazu še vedno določi tip.
    \item \komentar {\textit{zoženje}} (angl. contraction) ki zagotavlja, da če lahko preverimo tip izraza z uporabo dveh enakih predpostavk, lahko isti izraz preverimo tudi z uporabo samo ene predpostavke. To pomeni, da lahko spremenljivko v izrazu uporabimo večkrat, ne da bi morali v kontekstu imeti več kopij te predpostavke.
\end{itemize}

Substrukturni sistemi tipov (angl. substructural type systems) ~\cite{pierce2004advanced} so sistemi tipov, pri katerih ne velja ena izmed treh strukturni lastnosti. Mednje sodi npr. \textit{urejen} (angl. ordered) sistem tipov, pri katerem ne velja nobena izmed treh lastnosti, kar v praksi pomeni, da morajo biti vse spremenljivke uporabljene natanko enkrat in to v vrstnem redu kot so bile deklarirane. V nadaljevanju si bomo podrobneje ogledali linearen sistem tipov, ki dovoljuje zamenjavo, ne pa tudi oslabitve in zoženja.

\section{Linearni tipi}
\label{sec:linearni-tipi}

% [x] Citiramo: Linear logic
% [x] Citiramo: Linear types can change the world!
% [x] Citiramo: Is there a use for linear logic?
% [x] Citiramo: Linear Haskell: practical linearity in a higher-order polymorphic language
% [x] Citiramo: Advanced topics in types and programming languages

% Kratek uvod v linearen sistem tipov
Linearen sistem tipov (angl. linear type system) je substrukturni sistem tipov, ki se od urejenega razlikuje v tem, da dovoljuje \textit{zamenjavo}. To pomeni, da zahteva, da je vsak objekt uporabljen \textit{natanko enkrat}, ne velja pa, da morajo biti ti uporabljeni v vrstnem redu, kot so bili deklarirani. Jeziki s sistemom linearnih tipov omogočajo pisanje programov, ki bolj varno upravljajo s pomnilnikom, saj zagotavljajo, da bo na vsako vrednost kazal natanko en kazalec, kar pomeni, da ne more priti do nenadzorovanih ali nepričakovanih sprememb podatkov, tudi če se program izvaja hkrati na več nitih. Prav tako pa omogočajo bolj natančen nadzor nad življenjskimi cikli spremenljivk, kar preprečuje pisanje programov, ki puščajo pomnilnik ali programov, ki ne sprostijo virov operacijskega sistema po uporabi~\cite{pierce2004advanced}.

% TODO: Manjka neka povezava med odstavkoma

% Bolj formalna definicija linearnosti
Pri linearnih sistemih tipov gre referenca izven dosega takoj, ko se pojavi na desni strani prirejanja ali ko je posredovana kot argument funkciji. S tem je zagotovljeno, da na en objekt na kopici vedno kaže natanko ena referenca. Funkcija $f$ je linearna, če \textit{uporabi} svoj argument natanko enkrat. Linearno funkcijo $f$, ki kot vhod sprejme argument tipa $\alpha$ in vrne rezultat tipa $\beta$, označimo z oznako $f :: \alpha \multimap \beta$ .

% TODO: Kaj točno pomeni, da funkcija uporabi argument natanko enkrat?
% Če je izraz $(f a) uporabljen natanko enkrat, potem je tudi argument $a$ uporabljen natanko enkrat.

Če sistem tipov ne omogoča oslabitve, potem je zagotovljeno, da nobene vrednosti ne moremo zavreči~\cite{wadler1991there}. V tem primeru leni izračun sploh ni potreben, saj bo vsaka vrednost zagotovo vsaj enkrat uporabljena. Če prepovemo pravilo zoženja, potem v jeziku vrednosti ne moremo podvajati, kar pomeni, da na vsako vrednost na pomnilniku kaže natanko ena referenca, zaradi česar tak jezik ne potrebuje avtomatičnega čistilca pomnilnika. V linearnem sistemu tipov sta obe pravili prepovedani, s čemer je zagotovljeno, da bo vsaka vrednost uporabljena \textit{natanko} enkrat, po svoji edini uporabi pa lahko tako sistem ustrezno sprosti pomnilnik. Težava, ki se pojavi pri takem jeziku pa je v tem, da je pogosto preveč omejujoč, saj spremenljivk ni mogoče podvajati ali zavreči~\cite{wadler1990linear}. Naslednji program prikazuje dve funkciji, ki se v jeziku z linearnim sistemom tipov ne bi prevedli. Funkcija \texttt{duplicate} namreč argument $x$ uporabi dvakrat, funkcija \texttt{fst} pa argumenta $y$ sploh ne uporabi, kar krši pravila linearnosti.

\begin{code-box}{Haskell}{Programski jezik z linearnim sistemom tipov \xmark}
duplicate x = (x, x)
fst (x, y) = x
\end{code-box}

% Uvedba nelinearnih vrednosti & GC
Zaradi teh omejitev, se v programske jezike poleg linearnih tipov pogosto uvede še nelinearne~\cite{pierce2004advanced, wadler1990linear, marshall2022linearity}. Nelinearne vrednosti so v takih jezikih posebej označene in omogočajo, da je vrednost uporabljena poljubno mnogokrat, tj. nič ali večkrat. Vendar pa uvedba nelinearnih tipov prinaša izzive pri upravljanju s pomnilnikom. Prevajalnik namreč ne more zanesljivo določiti, kdaj na določeno vrednost ne kaže več nobena referenca, kar pomeni, da je za čiščenje nelinearnih vrednosti v jeziku še vedno potrebna implementacija avtomatičnega čistilca pomnilnika.

% Wadlerjev sistem linearnih tipov
\subsubsection{Girardova linearna logika}

Sam sistem linearnih tipov temelji na Girardovi linearni logiki~\cite{girard1987linear}. Ta vsebuje tako linearne, kot tudi nelinearne tipe, prehajanje med njimi pa je omogočeno s pomočjo pravil \komentar{promocije} (angl. promotion) in \komentar{derelikcije} (angl. dereliction).

% Kaj je promocija
\komentar{Promocija} je pravilo, ki omogoča deljenje vrednosti, če je zagotovljeno, da je mogoče deliti tudi vse proste spremenljivke, ki se v vrednosti pojavijo. Če bi bila katera izmed prostih spremenljivk linearna, bi z deljenjem nanjo ustvarili več referenc, kar pa krši pravila linearnosti. Promocija torej omogoča, da linearno vrednost pretvorimo v nelinearno in jo kot tako uporabimo večkrat oziroma sploh ne.

% Kaj je derelikcija
\komentar{Derelikcija} je, v kontekstu linearnih tipov, operacija, ki omogoča pretvorbo nelinearnega tipa v linearnega~\cite{wadler1991there}. S pravilom zoženja omogočimo, da lahko nelinearne vrednosti uporabimo večkrat, s pravilom oslabitve o\-mo\-go\-či\-mo, da vrednost sploh ni uporabljena, pravilo derelikcije pa omogoči, da nelinearno vrednost uporabimo natanko enkrat. tj. linearno. Brez \komentar{derelikcije} v jeziku namreč nelinearnih vrednosti ni mogoče uporabljati kot argumente linearnih funkcij. Toda zaradi pravila \komentar{derelikcije} ni mogoče zagotoviti, da ima linearen tip le eno referenco, kar pomeni, da tudi pomnilnika za linearne tipe ni mogoče sprostiti takoj po njihovi prvi uporabi.

% Steadfast tipi
\subsubsection{Wadlerjev sistem \komentar{steadfast} tipov}
Wadler v svojem delu~\cite{wadler1990linear} predstavi \textit{len} programski jezik z linearnim sistemom tipov. Tipi so razdeljeni na dve družini, med njima pa ni mogoče implicitno prehajati z uporabo \komentar{promocije} oziroma \komentar{derelikcije}. Linearni tipi v jeziku predstavljajo reference z možnostjo pisanja (angl. write access), medtem ko nelinearni tipi omogočajo le dostop za branje (angl. read-only access). Za sestavljene podatkovne tipe v jeziku velja, da nelinearni tipi ne smejo vsebovati referenc na linearne tipe. Ker lahko nelinearne tipe podvajamo, bi se v tem primeru namreč lahko zgodilo, da bi podvojili tudi referenco na linearen tip, s čemer pa bi prekršili pravila linearnosti v jeziku.

\begin{code-box}{Haskell}{Wadlerjev len programski jezik}
let! (x) y = u in v
\end{code-box}

Prehajanje med linearnimi in nelinearnimi tipi je omogočeno le na en način: \emph{eksplicitno} s pomočjo izraza \texttt{let!}. Pri tem je mogoče znotraj izraza $u$, vrednost $x$ uporabljati \emph{nelinearno}, a le za branje. Več kot ena referenca na vrednost na pomnilniku je namreč varna, dokler obstaja \emph{v trenutku posodobitve} nanjo samo ena referenca. V izrazu $v$ pa je tip spremenljivke $x$ ponovno linearen, kar pomeni, da je vrednost mogoče neposredno posodabljati ali izbrisati iz pomnilnika.

Toda, zaradi lenosti jezika, bi lahko spremenljivka $y$ preživela \texttt{let!} izraz, pri tem pa vsebovala kazalec na spremenljivko $x$, ki je linearno uporabljena v telesu izraza $v$. Izraz \texttt{let!} je zato edini izraz, ki se ne izvaja leno, temveč neučakano. Nujno je namreč izračunati \textit{celoten} izraz $u$ preden se začne izvajati izraz $v$, da zagotovimo, da bodo vse reference na $x$ odstranjene preden se bo začel izračun $v$, ki bo mogoče sprostil vrednost spremenljivke $x$. To imenujemo tudi za \textit{zelo neučakani izračun} (angl. hyperstrict evaluation).

Wadler v svojem delu torej uvede dva povsem ločena ``svetova`` tipov, med katerimi je moč prehajati z uporabo izraza \texttt{let!}. Tak sistem tipov poimenuje tudi za \komentar{steadfast} (angl. steadfast)~\cite{wadler1991there}. Pri tem pokaže, da je zaradi uvedbe nelinearnosti, še vedno potreben avtomatski čistilec pomnilnika, saj so nelinearne vrednosti lahko poljubno podvojene. Pokaže tudi, da je potrebno zagotoviti, da se vsi nelinearni dostopi do objekta na pomnilniku izvedejo pred dostopom za pisanje, kar pa je pri lenem izračunu skoraj nemogoče izvesti, zato v \texttt{let!} izraze ponovno uvede neučakan izračun.

Linearni tipi so bili tudi že dodani v Haskell kot razširitev sistema tipov~\cite{bernardy2018linear}. Najpomembnejša pridobitev članka je vpeljava linearnih tipov v Haskell, ki omogoča varno in učinkovito posodabljanje podatkovnih struktur ter zagotavljanje pravilnega dostopa do zunanjih virov, kot so datoteke in omrežni viri. Avtorji so dokazali, da je mogoče linearne tipe vključiti v obstoječi programski jezik s spreminjanjem algoritma za preverjanje in izpeljavo tipov, ne pa tudi s samim spreminjanjem abstraktnega STG stroja na katerem se izvaja redukcija grafa.

\section{Unikatni tipi}
\label{sec:unikatni-tipi}

% [x] Citiramo: Linearity and Uniqueness: An Entente Cordiale
% [ ] Citiramo: Functional Ownership through Fractional Uniqueness
% [ ] Citiramo: Quantitative Program Reasoning with Graded Modal Types

% Definicija unikatnih tipov
\komentar{Unikatni tipi} (angl. uniqueness types) so namenjeni zagotavljanju, da na vsako vrednost kaže natanko ena referenca, kar omogoča učinkovito implementacijo sistema, ki omogoča posodobitve na mestu (angl. in-place updates)~\cite{marshall2022linearity}. V literaturi se unikatni tipi pogosto kar enačijo z linearnimi tipi oziroma se obravnavajo kot posebna vrsta linearnih tipov~\cite{pierce2004advanced, bernardy2018linear}. Za vrednosti linearnih tipov velja, da v \textit{prihodnosti} zagotovo ne bojo podvojene ali zavržene, medtem ko je za unikatne vrednosti zagotovljeno, da v \textit{preteklosti} še niso bile podvojene~\cite{marshall2022linearity, marshall2024functional}.

Ker včasih želimo da na eno vrednost kažeta dva kazalca, se tudi pri unikatnih tipih, podobno kot pri linearnih, uvede \emph{neomejene} (angl. unrestricted) vrednosti. Razlika med linearnimi in unikatnimi tipi je v zmožnosti prehajanja med neomejenimi in omejenimi vrednostmi. Kot smo videli v poglavju \ref{sec:linearni-tipi}, lahko pri linearnem sistemu tipov med linearnimi in nelinearnimi vrednostmi prehajamo s pomočjo pravil \komentar{promocije} in \komentar{derelikcije}. S pomočjo derelikcije je lahko nelinearna spremenljivka v nadaljevanju uporabljena linearno, pri tem pa ni mogoče zagotoviti, da na to nelinearno spremenljivko kaže natanko ena referenca. To pa tudi pomeni, da v linearnem sistemu ne moremo zagotoviti unikatnosti vrednosti.

Pri unikatnih sistemih tipov ni pravila, ki bi omogočala pretvorbo vrednosti neomejenega tipa nazaj v vrednost unikatnega tipa. Ker na neomejene tipe namreč lahko kaže poljubno mnogo kazalcev, jih ni mogoče obravnavati kot unikatne. Kot bomo lahko videli v poglavju \ref{sec:granule}, programski jezik Granule tako pretvorbo omogoča s ključno besedo \texttt{clone}, ki globoko kopira (angl. deep copy) vrednost na pomnilniku. S tem je sicer zagotovljena unikatnost, a je kopiranje precej neučinkovito, saj je potrebno klonirati celoten podgraf na pomnilniku~\cite{marshall2024functional}. Pri sistemih unikatnih tipov torej velja, da je vrednost unikatnega tipa mogoče pretvoriti v neomejeno vrednost, obratno pa ne. Linearni tipi so tako bolj uporabni pri zagotavljanju pravilne uporabe računalniških sredstev (angl. resource), medtem ko sistemi unikatnih tipov omogočajo ponovno uporabo struktur na pomnilniku in posodabljanje le-teh na mestu~\cite{marshall2022linearity}.

% Povezava Wadlerjevih steadfast tipov in unikatnih tipov
V sistemu tipov, kjer je mora biti \textit{vsaka} vrednost linearna, je zagotovljeno tudi, da je vsaka vrednost unikatna~\cite{marshall2022linearity}. Linearni tipi namreč ne dovoljujejo podvajanja, zaradi česar je zagotovljeno, da bo referenca na nek vrednost vedno le ena. Wadlerjev sistem \komentar{steadfast} linearnih tipov~\cite{wadler1990linear} omeji pravili \komentar{promocije} in \komentar{derelikcije}, s čemer v jezik ponovno uvede pogoj za unikatnost reference. Sistem tipov jezika glede na definicijo bolj ustreza sistemu linearnih tipov, ki pa takrat še ni bil definiran.

\subsubsection{Programski jezik Clean}

% Programski jezik Clean
Eden izmed programskih jezikov, ki uporabljajo sistem unikatnih tipov, je len funkcijski jezik Clean~\cite{smetsers1994guaranteeing}. Za razliko od Haskella, ki za mutacije notranjega stanja in vhodno-izhodne operacije uporablja monade, Clean le-te implementira s pomočjo sistema unikatnih tipov. Prav tako zna prevajalnik unikatne vrednosti spreminjati na mestu, kar zmanjša porabo pomnilnika in omogoča hitrejše izvajanje programov.

Spodnji primer prikazuje program v jeziku Clean. Konstruktor tipa $*T$ predstavlja unikaten tip $T$. Če predpostavljamo, da je \texttt{eat} tipa \texttt{Cake -> Happy} in \texttt{have} tipa \texttt{Cake -> Cake}, potem je naslednji program veljaven. 

\begin{code-box}{haskell}{Clean \cmark}
possible :: *Cake -> (Happy, Cake)
possible cake = (eat cake, have cake)
\end{code-box}

Kot lahko vidimo, se argument \texttt{cake} v telesu funkcije pojavi dvakrat. Funkcija vzame unikaten kazalec na vrednost \texttt{Cake}, ker pa jo v telesu dvakrat uporabi, vrnjena vrednost izgubi unikatnost. Vrnjena vrednost je tako neomejenega tipa.

\section{Programski jezik Granule}
\label{sec:granule}

Programski jezik Granule~\cite{orchard2019quantitative} je \textit{neučakan} močno tipiziran (angl. strongly typed) funkcijski jezik, ki v svojem sistemu tipov združuje linearne, indeksne in \komentar{graded modal} (angl. graded modal) tipe. Granule v svojem sistemu tipov uporablja princip podatkov kot virov (angl. data as a resource). Za upravljanje s pomnilnikom je uporabljen avtomatičen čistilec. 

S pomočjo linearnih tipov je v jeziku zagotovljen pogled na podatke kot na fizičen vir, ki mora biti uporabljen enkrat, nato pa nikoli več. Neomejena uporaba nekega vira mora biti v jeziku označena z eksponentnim \komentar{graded modalityjem} $!A$, ki omogoča, da je vrednost lahko deljena poljubno mnogokrat. Jezik poleg neomejene uporabe omogoča še določanje zgornje meje uporabe podatkov s pomočjo omejene linearne logike (angl. bounded linear logic)~\cite{girard1992bounded}. Tako lahko namesto neomejene uporabe $!A$, določimo zgornjo mejo uporabe vrednosti. Tip $!_2 \, A$ npr. označuje vrednost tipa $A$, ki je lahko uporabljena \textit{največ} dvakrat.

Preverjanje tipov je v jeziku Granule implementirano v dveh stopnjah: najprej se za izraze v programu izpelje trditve in omejitve glede njihovih tipov~\cite{orchard2019quantitative}, nato pa se trditve dokaže s pomočjo dokazovalnika Z3~\cite{demoura2008z3}. Izpeljava tipov (angl. type inference) za \komentar{statične} (angl. top-level) funkcije ni podprta, zato morajo biti označeni tipi vseh funkcij na statičnem nivoju. V Granule so vse funkcije privzeto linearne, zato se namesto operatorja za linearne funkcije $a \multimap b$, uporablja kar zapis $a \to b$. Neomejeni tipi kot jih poznamo iz linearne logike, so označeni s pripono \texttt{[]}. Taka oznaka je ekvivalentni oznaki \texttt{!}, ki jo je definiral Girard~\cite{girard1987linear}, omogoča pa poljubno mnogo uporab spremenljivke, tako da omogoči pravili \komentar{oslabitve} in \komentar{zoženja}. Jezik prav tako omogoča omejevanje števila uporab neke spremenljivke s pomočjo pripone \texttt{[n]}, ki določa, da je lahko število uporab spremenljivke največ $n$.

Naslednji primer prikazuje identiteto, implementirano v jeziku Granule. Iz \komentar{prototipa} (angl. type annotation) lahko prevajalnik razbere, da je \texttt{id} funkcija, ki sprejme spremenljivko poljubnega tipa in jo zaradi linearnosti (konstruktor tipa $t \to t$), uporabi natanko enkrat.

\begin{code-box}{text}{Granule \cmark}
id : ∀ {t : Type} . t → t
id x = x
\end{code-box}

V naslednjem primeru sta implementirani funkciji \texttt{drop} in \texttt{copy}, ki v jeziku z le linearnimi tipi nista mogoči. Pri obeh funkcijah je označeno število uporab argumenta. Funkcija \texttt{drop} svojega argumenta ne uporabi, zato je označena z števnostjo \texttt{t [0]}, funkcija \texttt{copy} pa svoj argument uporabi dvakrat, kar je označeno s števnostjo \texttt{t [2]}.

\begin{code-box}{text}{Granule \cmark}
drop : ∀ {t : Type} . t [0] → ()
drop [x] = ()

copy : ∀ {t : Type} . t [2] → (t, t)
copy [x] = (x, x)
\end{code-box}

\subsubsection{Unikatni tipi v jeziku Granule}
% Razširitev Granule: unikatni tipi
V programski jezik Granule je bila eksperimentalno poleg linearnih tipov dodana tudi podpora za unikatne tipe~\cite{marshall2022linearity}. Linearnost v takem jeziku omogoča boljši nadzor nad upravljanjem s sredstvi, medtem ko je unikatnost uporabljena za varno posodabljanje podatkov na mestu. Prevajalnik jezika Granule zna s pomočjo izpeljanih unikatnih tipov, generirati optimizirano Haskell kodo, ki \komentar{mutira} sezname na mestu. Avtorji so pokazali, da je uporaba unikatnih tipov za delo s tabelami učinkovitejša od uporabe nespremenljivih tabel (angl. immutable arrays). Rezultati so pokazali, da je različica z unikatnimi tabelami hitrejša in porabi bistveno manj časa za upravljanje s pomnilnikom. To je posledica dejstva, da se unikatni podatki \komentar{alocirajo} izven kopice GHC prevajalnika in se lahko eksplicitno sprostijo po njihovi uporabi. Avtorji tudi poudarijo, da sistem unikatnih tipov omogoča varno in učinkovito mutacijo podatkov neposredno v funkcijskem jeziku, brez potrebe po uporabi nepreverjene kode (angl. unsafe code), ki je npr. prisotna v Haskell knjižnicah za učinkovite operacije nad tabelami.

\subsubsection{Model lastništva v jeziku Granule}
% Razširitev Granule: ownership model

Pozneje je bil sistem tipov jezika Granule še dodatno razširjen s pravili za lastništvo in izposojo na podlagi tistih iz Rusta~\cite{marshall2024functional}. Avtorji v članku povežejo koncepta linearnih in unikatnih tipov in vgradijo sistem lastništva in izposoje v sistem tipov za funkcijski programski jezik.

Sistem lastništva v Rustu določa, da z vsako vrednostjo v pomnilniku upravlja natanko ena referenca. To se ujema z definicijo unikatnih vrednosti, zato avtorji osnovo za lastništvo objektov postavijo na sistem unikatnih tipov. Ker vrednosti unikatnega tipa ni mogoče podvajati, avtorji uvedejo ključno besedo \texttt{clone}, ki omogoča globoko kopiranje (angl. deep copy) objekta v pomnilniku. Po operaciji na novonastali objekt zagotovo kaže le en kazalec, s čemer je omogočeno, da lahko vrednost poljubnega tipa pretvorimo v unikaten tip. Dodana je še ključna beseda \texttt{share}, ki omogoča deljenje izraza. Pri deljenju se vrednost unikatnega tipa $*A$ pretvori v neomejeno vrednost $!A$, ki je od takrat naprej ni mogoče ponovno pretvoriti v unikaten tip. Za čiščenje pomnilnika neomejenih tipov se še vedno uporablja avtomatski čistilec, medtem ko se za čiščenje unikatnih in linearnih tipov uporablja Rustov model upravljanja s pomnilnikom.

% Za sistem lastništva v Rustu velja, da na vsako vrednost na pomnilniku kaže natanko ena referenca. To ravno sovpada z definicijo unikatnih vrednosti, zato avtorji lastništvo objektov temeljijo na sitemu unikatnih tipov. Ker vrednosti unikatnega tipa ni mogoče podvajati, avtorji uvedejo ključno besedo \texttt{clone}, ki izvede globoko kopiranje objekta na pomnilniku. S tem je torej omogočeno, da lahko vrednost poljubnega tipa pretvorimo v unikaten tip. Dodana je še ključna beseda \texttt{share}, ki omogoča deljenje izraza. Pri deljenju se vrednost unikatnega $*A$ tipa pretvori v neomejeno vrednost $!A$, od takrat naprej pa je ni več mogoče pretvoriti v unikaten tip. Za čiščenje pomnilnika \komentar{graded modal} tipov, se še vedno uporablja avtomatski čistilec, medtem ko se za čiščenje unikatnih in linearnih tipov uporablja Rustov model upravljanja s pomnilnikom.

Izposoje so v jeziku implementirane s pomočjo delnih pravic (angl. fractional permissions)~\cite{boyland2003checking}. Tipi z delnimi pravicami so označeni $\&_p A$, kjer $p$ predstavlja ali vrednost $*$ ali pa ulomek na intervalu $[0, 1]$. Vrednosti tipa $\&_{*} A$ predstavljajo unikatne izposoje in so z vrednostmi unikatnih tipov povezane s pomočjo enakosti $*A \equiv \&_{*} A$. Spremenljive izposoje so označene s tipom $\&_1 A$, pri nespremenljivih izposojah pa je $p < 1$. Z izrazom \texttt{split} je omogočeno, da se referenca $\&_p A$ razdeli na dve novi referenci, ki kažeta na isti objekt kot prvotna referenca. Novi referenci sta označeni s polovico dovoljenj prvotne reference, tj. referenci imata tipa $\&_{\frac{p}{2}} A$. Z izrazom \texttt{join} se dve obstoječi referenci združita v eno novo referenco, pri čemer se dovoljenja združenih referenc seštejeta~\cite{marshall2024functional}. Tako lahko spremenljivo referenco s pomočjo izraza \texttt{split} razdelimo na dve nespremenljivi referenci in s pomočjo izraza \texttt{join} ponovno združimo v spremenljivo referenco.

% TODO: Napiši še kaj o call-by-need vs call-by-value?
% Call-by-value was chosen for simplicity and since the effectful part of Gr is necessarily CBV (to avoid pitfalls of laziness with side effects).~\cite{orchard2019quantitative} Previously, Brunel et al. [2014] provided a CBN abstract machine for BLL-style coeffects where reduction is suspended at promotion, i.e., [t] is a value, and Gaboardi et al. [2016] gave a CBN-based equational theory. This differs to our approach, but our system does not preclude a CBN semantics, which is further work. Such a semantics would trigger reduction when matching non-values against constructor patterns, which would cohere nicely with the consumption constraints on grades induced by pattern matching. The CBV approach, whilst simple, shows that our technique does not force us into the CBN semantics used previously, suggesting that we could add graded modal types to an existing eager language. Note that we do not parameterise our system by denotational models of the graded modalities, i.e, particular graded (co)monads. Exploring this, and its relationship to operational models, is future work.