\komentar{Mislim, da je trenutna vsebina tega poglavja to, kar bi o sorodnem delu želel povedati. Potrebno se mi zdi še napisati nek boljši uvod v poglavje.}

Da je upravljanje s pomnilnikom v funkcijskih programskih jezikih še vedno aktualno področje raziskovanja, priča mnogo eksperimentalnih jezikov razvitih v zadnjih nekaj letih. V sledečem poglavju bomo na kratko predstavili nekaj funkcijskih jezikov, ki za upravljanje s pomnilnikom uporabljajo manj konvencionalne pristope, nato pa se bomo podrobneje posvetili sistemom tipov in na kratko predstavili \textit{neučakan} programski jezik Granule, ki za upravljanje s pomnilnikom že uporablja princip lastništva in izposoje na podlagi tistega iz Rusta.

Ena izmed alternativ STG stroja za izvajanje jezikov z nestrogo semantiko je  prevajalnik GRIN~\cite{boquist1997grin} (angl. graph reduction intermediate notation), ki podobno kot STG stroj definira majhen funkcijski programski jezik, ki ga zna izvajati s pomočjo redukcije grafa. Napisane ima prednje dele za Haskell, Idris in Agdo, ponaša pa se tudi z zmožnostjo optimizacije celotnih programov (angl. whole program optimization)~\cite{podlovics2022modern}. Za upravljanje s pomnilnikom se v trenutni različici uporablja čistilec pomnilnika~\cite{boquist1999code}.

Na podlagi principa lastništva in izposoje iz Rusta je nastal len funkcijski programski jezik Blang~\cite{turk2022len}. Interpreter jezika zna pomnilnik za ovojnice izrazov in spremenljivk med izvajanjem samodejno sproščati brez uporabe čistilcev, zatakne pa se pri sproščanju funkcij in delnih aplikacij. \komentar{Potrebno je bolj podrobno opisati kako deluje Blang.}

Programski jezik micro-mitten~\cite{corbyn:practical-static-memory-management} je programski jezik, podoben Rustu, ki za upravljanje s pomnilnikom uporablja princip ASAP (angl. As Static As Possible)~\cite{proust2017asap}. Prevajalnik namesto principa lastništva izvede zaporedje analiz pretoka podatkov (angl. data-flow), namen katerih je aproksimirati statično živost spremenljivk na kopici. Pri tem prevajalnik ne postavi dodatnih omejitev za pisanje kode, kot jih poznamo npr. v Rustu, kjer mora programer za pisanje delujoče in učinkovite kode v vsakem trenutku vedeti, katera spremenljivka si objekt lasti in kakšna je njena življenjska doba. Metoda ASAP še ni dovolj raziskana in tako še ni primerna za produkcijske prevajalnike.