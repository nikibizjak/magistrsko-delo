\section{Sistemi tipov}
\label{sec:sistemi-tipov}

% Kratek opis sistemov tipov
Sistemi tipov formalno definirajo pravila za določanje podatkovnega tipa poljubnega  izraza v programu. Poleg tega postavljajo omejitve, ki jih morajo vsi izrazi v programu izpolnjevati. Med njimi določijo katere operacije se lahko izvajajo nad izrazi z določenimi tipi in kakšnega tipa je izračunan rezultat. Tipični primer tovrstnih pravil je, da se aritmetične operacije, kot sta seštevanje in množenje, lahko izvajajo le nad numeričnimi tipi, medtem ko je seštevanje nizov in števil prepovedano.

Glede na način preverjanja tipov, ločimo statično in dinamično tipiziranje. Pri jezikih s statičnim tipiziranjem (angl. static typing) se podatkovni tipi izpeljejo oziroma izračunajo med prevajanjem, medtem ko se pri dinamičnem tipiziranju (angl. dynamic typing) preverjanje tipov izvaja med samim izvajanjem programa. Tako je pri statično tipiziranih jezikih, kot sta Java in Haskell, zagotovljeno, da se napake, povezane z nezdružljivostjo tipov, odkrijejo že med prevajanjem in ne med izvajanjem programa. Na drugi strani so jeziki z dinamičnim tipiziranjem, kot sta Python in JavaScript, podvrženi večjemu tveganju za napake med izvajanjem.

% STG ni tipiziran (Haskell pa je)
V poglavju \ref{ch:stg} smo lahko videli, da STG jezik ne vključuje preverjanja tipov, vendar to ne pomeni, da ni tipiziran. Podatkovni tipi so namreč izpeljani in preverjeni pred prevajanjem Haskella v STG. Izrek o varnosti sistemov tipov Haskella zagotavlja, da \textit{med izvajanjem} STG jezika z redukcijo grafa ne bo prišlo do napak, povezanih z nezdružljivostjo tipov.

% Na kratko o izpeljavi / preverjanju tipov
Pri izpeljavi oziroma preverjanju tipov, v kontekstu $\Gamma$ hranimo predpostavke o tipih spremenljivk, na katere smo že naleteli. Te predpostavke pomagajo pri določitvi tipov kompleksnejših izrazov in funkcij, saj lahko z uporabo že znanih tipov preverjamo in izpeljujemo tipe novih izrazov. Na ta način lahko v vsakem koraku preverimo, ali so tipi skladni s pravili sistema tipov.

% Substrukturni sistemi tipov
Programski jeziki imajo običajno neomejen (angl. unrestricted) sistem tipov, ki omogoča, da lahko do spremenljivk dostopamo poljubno mnogokrat in v poljubnem vrstnem redu. To je zagotovljeno s pomočjo treh strukturnih lastnosti:
\begin{itemize}
    \itemsep 0em
    \item \komentar{\textit{zamenjava}} (angl. exchange) zagotavlja, da vrstni red spremenljivk v kontekstu tipov ni pomemben. Če je preverjanje tipov uspešno v nekem kontekstu $\Gamma$, potem bo uspešno tudi v kateremkoli drugem kontekstu, ki je sestavljen kot permutacija predpostavk iz $\Gamma$.
    \item \komentar{\textit{oslabitev}} (angl. weakening) zagotavlja, da se lahko, kljub dodajanju neuporabnih predpostavk v kontekst tipov, izrazu še vedno določi tip.
    \item \komentar {\textit{zoženje}} (angl. contraction) ki zagotavlja, da če lahko preverimo tip izraza z uporabo dveh enakih predpostavk, lahko isti izraz preverimo tudi z uporabo samo ene predpostavke. To pomeni, da lahko spremenljivko v izrazu uporabimo večkrat, ne da bi morali v kontekstu imeti več kopij te predpostavke.
\end{itemize}

Substrukturni sistemi tipov (angl. substructural type systems) ~\cite{pierce2004advanced} so sistemi tipov, pri katerih ne velja ena izmed treh strukturni lastnosti. Mednje sodi npr. \textit{urejen} (angl. ordered) sistem tipov, pri katerem ne velja nobena izmed treh lastnosti, kar v praksi pomeni, da morajo biti vse spremenljivke uporabljene natanko enkrat in to v vrstnem redu kot so bile deklarirane. V nadaljevanju si bomo podrobneje ogledali linearen sistem tipov, ki dovoljuje zamenjavo, ne pa tudi oslabitve in zoženja.

\subsection{Linearni tipi}
\label{sec:linearni-tipi}

% [x] Citiramo: Linear logic
% [x] Citiramo: Linear types can change the world!
% [x] Citiramo: Is there a use for linear logic?
% [x] Citiramo: Linear Haskell: practical linearity in a higher-order polymorphic language
% [x] Citiramo: Advanced topics in types and programming languages

% Kratek uvod v linearen sistem tipov
Linearen sistem tipov (angl. linear type system) je substrukturni sistem tipov, ki se od urejenega razlikuje v tem, da dovoljuje \textit{zamenjavo}. To pomeni, da zahteva, da je vsak objekt uporabljen \textit{natanko enkrat}, ne velja pa, da morajo biti ti uporabljeni v vrstnem redu, kot so bili deklarirani. Jeziki s sistemom linearnih tipov omogočajo pisanje programov, ki bolj varno upravljajo s pomnilnikom, saj zagotavljajo, da bo na vsako vrednost kazal natanko en kazalec, kar pomeni, da ne more priti do nenadzorovanih ali nepričakovanih sprememb podatkov, tudi če se program izvaja hkrati na več nitih. Prav tako pa omogočajo bolj natančen nadzor nad življenjskimi cikli spremenljivk, kar preprečuje pisanje programov, ki puščajo pomnilnik ali programov, ki ne sprostijo virov operacijskega sistema po uporabi~\cite{pierce2004advanced}.

% TODO: Manjka neka povezava med odstavkoma

% Bolj formalna definicija linearnosti
Pri linearnih sistemih tipov gre referenca izven dosega takoj, ko se pojavi na desni strani prirejanja ali ko je posredovana kot argument funkciji. S tem je zagotovljeno, da na en objekt na kopici vedno kaže natanko ena referenca. Funkcija $f$ linearna, če \textit{uporabi} svoj argument natanko enkrat. Oznaka $f :: \alpha \multimap \beta$ predstavlja tip linearne funkcije $f$, ki sprejme argument tipa $\alpha$ in vrne rezultat tipa $\beta$.

% TODO: Kaj točno pomeni, da funkcija uporabi argument natanko enkrat?
% Če je izraz $(f a) uporabljen natanko enkrat, potem je tudi argument $a$ uporabljen natanko enkrat.

Če sistem tipov ne omogoča oslabitve, potem je zagotovljeno, da nobene vrednosti ne moremo zavreči~\cite{wadler1991there}. V tem primeru leni izračun sploh ni potreben, saj bo vsaka vrednost zagotovo vsaj enkrat uporabljena. Če prepovemo pravilo zoženja, potem v jeziku vrednosti ne moremo podvajati, kar pomeni, da na vsako vrednost na pomnilniku kaže natanko ena referenca, zaradi česar tak jezik ne potrebuje avtomatičnega čistilca pomnilnika. V linearnem sistemu tipov sta obe pravili prepovedani, s čemer je zagotovljeno, da bo vsaka vrednost uporabljena \textit{natanko} enkrat, po svoji edini uporabi pa lahko tako sistem ustrezno sprosti pomnilnik. Težava, ki se pojavi pri takem jeziku pa je v tem, da je pogosto preveč omejujoč, saj spremenljivk ni mogoče podvajati ali zavreči~\cite{wadler1990linear}. Naslednji program prikazuje dve funkciji, ki se v jeziku z linearnim sistemom tipov ne bi prevedli. Funkcija \texttt{duplicate} namreč argument $x$ uporabi dvakrat, funkcija \texttt{fst} pa argumenta $y$ sploh ne uporabi, kar krši pravila linearnosti.

\begin{code-box}{Haskell}{Programski jezik z linearnim sistemom tipov}
duplicate x = (x, x)
fst (x, y) = x
\end{code-box}

% Uvedba nelinearnih vrednosti & GC
Zaradi teh omejitev, se v programske jezike poleg linearnih tipov pogosto uvede še nelinearne~\cite{pierce2004advanced, wadler1990linear, marshall2022linearity}. Nelinearne vrednosti so v takih jezikih posebej označene in omogočajo, da je vrednost uporabljena poljubno mnogokrat, tj. nič ali večkrat. Vendar pa uvedba nelinearnih tipov prinaša izzive pri upravljanju s pomnilnikom. Prevajalnik namreč ne more zanesljivo določiti, kdaj na določeno vrednost ne kaže več nobena referenca, kar pomeni, da je za čiščenje nelinearnih vrednosti v jeziku še vedno potrebna implementacija avtomatičnega čistilca pomnilnika.

% Wadlerjev sistem linearnih tipov
\subsubsection{Girardova linearna logika}

Sam sistem linearnih tipov temelji na Girardovi linearni logiki~\cite{girard1987linear}. Ta vsebuje tako linearne, kot tudi nelinearne tipe, prehajanje med njimi pa je omogočeno s pomočjo pravil \komentar{promocije} (angl. promotion) in \komentar{derelikcije} (angl. dereliction).

% Kaj je promocija
\komentar{Promocija} je pravilo, ki omogoča deljenje vrednosti, če je zagotovljeno, da je mogoče deliti tudi vse proste spremenljivke, ki se v vrednosti pojavijo. Če bi bila katera izmed prostih spremenljivk linearna, bi z deljenjem nanjo ustvarili več referenc, kar pa krši pravila linearnosti. Promocija torej omogoča, da linearno vrednost pretvorimo v nelinearno in jo kot tako uporabimo večkrat oziroma sploh ne.

% Kaj je derelikcija
\komentar{Derelikcija} je, v kontekstu linearnih tipov, operacija, ki omogoča pretvorbo nelinearnega tipa v linearnega~\cite{wadler1991there}. S pravilom zoženja omogočimo, da lahko nelinearne vrednosti uporabimo večkrat, s pravilom oslabitve o\-mo\-go\-či\-mo, da vrednost sploh ni uporabljena, pravilo derelikcije pa omogoči, da nelinearno vrednost uporabimo natanko enkrat. tj. linearno. Brez \komentar{derelikcije} v jeziku namreč nelinearnih vrednosti ni mogoče uporabljati kot argumente linearnih funkcij. Toda zaradi pravila \komentar{derelikcije} ni mogoče zagotoviti, da ima linearen tip le eno referenco, kar pomeni, da tudi pomnilnika za linearne tipe ni mogoče sprostiti takoj po njihovi prvi uporabi.

% Steadfast tipi
\subsubsection{Wadlerjev sistem \komentar{steadfast} tipov}
Wadler v svojem delu~\cite{wadler1990linear} predstavi \textit{len} programski jezik z linearnim sistemom tipov. Tipi so razdeljeni na dve družini, med njima pa ni mogoče implicitno prehajati z uporabo \komentar{promocije} oziroma \komentar{derelikcije}. Linearni tipi v jeziku predstavljajo reference z možnostjo pisanja (angl. write access), medtem ko nelinearni tipi omogočajo le dostop za branje (angl. read-only access). Za sestavljene podatkovne tipe v jeziku velja, da nelinearni tipi ne smejo vsebovati referenc na linearne tipe. Ker lahko nelinearne tipe podvajamo, bi se v tem primeru namreč lahko zgodilo, da bi podvojili tudi referenco na linearen tip, s čemer pa bi prekršili pravila linearnosti v jeziku.

Prehajanje med linearnimi in nelinearnimi tipi je omogočeno le na en način, \textit{eksplicitno} s pomočjo izraza \texttt{let!}. Pri tem je mogoče znotraj izraza $u$, vrednost $x$ uporabljati \textit{nelinearno}, a le za branje. Več kot ena referenca na vrednost na pomnilniku je namreč varna, dokler obstaja \textit{v trenutku posodobitve} nanjo samo ena referenca. V izrazu $v$ pa je tip spremenljivke $x$ ponovno linearen, kar pomeni, da je vrednost mogoče neposredno posodabljati ali izbrisati iz pomnilnika.

\begin{code-box}{Haskell}{Wadlerjev len programski jezik}
let! (x) y = u in v
\end{code-box}

Toda, zaradi lenosti jezika, bi lahko spremenljivka $y$ preživela \texttt{let!} izraz, pri tem pa vsebovala kazalec na spremenljivko $x$, ki je linearno uporabljena v telesu izraza $v$. Izraz \texttt{let!} je zato edini izraz, ki se ne izvaja leno, temveč neučakano. Nujno je namreč izračunati \textit{celoten} izraz $u$ preden se začne izvajati izraz $v$, da zagotovimo, da bodo vse reference na $x$ odstranjene preden se bo začel izračun $v$, ki bo mogoče sprostil vrednost spremenljivke $x$. To imenujemo tudi za \textit{zelo neučakani izračun} (angl. hyperstrict evaluation).

Wadler v svojem delu torej uvede dva povsem ločena ``svetova`` tipov, med katerimi je moč prehajati z uporabo izraza \texttt{let!}. Tak sistem tipov poimenuje tudi za \komentar{steadfast} (angl. steadfast)~\cite{wadler1991there}. Pri tem pokaže, da je zaradi uvedbe nelinearnosti, še vedno potreben avtomatski čistilec pomnilnika, saj so nelinearne vrednosti lahko poljubno podvojene. Pokaže tudi, da je potrebno zagotoviti, da se vsi nelinearni dostopi do objekta na pomnilniku izvedejo pred dostopom za pisanje, kar pa je pri lenem izračunu skoraj nemogoče izvesti, zato v \texttt{let!} izraze ponovno uvede neučakan izračun.

Linearni tipi so bili tudi že dodani v Haskell kot razširitev sistema tipov~\cite{bernardy2018linear}. Najpomembnejša pridobitev članka je vpeljava linearnih tipov v Haskell, ki omogoča varno in učinkovito posodabljanje podatkovnih struktur ter zagotavljanje pravilnega dostopa do zunanjih virov, kot so datoteke in omrežni viri. Avtorji so dokazali, da je mogoče linearne tipe vključiti v obstoječi programski jezik s spreminjanjem algoritma za preverjanje in izpeljavo tipov, ne pa tudi s samim spreminjanjem abstraktnega STG stroja na katerem se izvaja redukcija grafa.

\subsection{Unikatni tipi}
\label{sec:unikatni-tipi}

% [x] Citiramo: Linearity and Uniqueness: An Entente Cordiale
% [ ] Citiramo: Functional Ownership through Fractional Uniqueness
% [ ] Citiramo: Quantitative Program Reasoning with Graded Modal Types

\komentar{Unikatni tipi} (angl. uniqueness types) so namenjeni zagotavljanju, da na vsako vrednost kaže natanko ena referenca, kar omogoča učinkovito implementacijo sistema, ki omogoča posodobitve na mestu (angl. in-place updates)~\cite{marshall2022linearity}.  V literaturi se unikatni tipi pogosto kar enačijo z linearnimi tipi oziroma se obravnavajo kot posebna vrsta linearnih tipov~\cite{pierce2004advanced, wadler1990linear, wadler1991there}.

... zagotavlja, da na vsako vrednost kaže natanko ena referenca.

V sistemu tipov, kjer je mora biti \textit{vsaka} vrednost linearna, je zagotovljeno tudi, da je vsaka vrednost unikatna~\cite{marshall2022linearity}. Linearni tipi namreč ne dovoljujejo podvajanja, zaradi česar je zagotovljeno, da bo referenca na nek vrednost vedno le ena. 

Programski jezik Clean

\subsection{Programski jezik Granule}
\label{sec:}
% \label{sec:unikaten-sistem-tipov}

Programski jezik Granule~\cite{orchard2019quantitative} je \textit{strog} funkcijski jezik, ki v svojem sistemu tipov združuje tako linearne, kot tudi \komentar{prevod} (angl. graded modal) tipe. 
Za čiščenje pomnilnika se uporablja avtomatski čistilec.

Granule uporablja linearen sistem tipov, pri katerem je potrebno nelinearne vrednosti označiti z eksponentnim graded modalityjem \texttt{!}.

% Iz orchard2019quantitative:
% Call-by-value was chosen for simplicity and since the effectful part of Gr is necessarily CBV (to avoid pitfalls of laziness with side effects). Previously, Brunel et al. [2014] provided a CBN abstract machine for BLL-style coeffects where reduction is suspended at promotion, i.e., [t] is a value, and Gaboardi et al. [2016] gave a CBN-based equational theory. This differs to our approach, but our system does not preclude a CBN semantics, which is further work. Such a semantics would trigger reduction when matching non-values against constructor patterns, which would cohere nicely with the consumption constraints on grades induced by pattern matching. The CBV approach, whilst simple, shows that our technique does not force us into the CBN semantics used previously, suggesting that we could add graded modal types to an existing eager language. Note that we do not parameterise our system by denotational models of the graded modalities, i.e, particular graded (co)monads. Exploring this, and its relationship to operational models, is future work.

V članku \cite{10.1145/3649848} programski jezik Granule razširijo s poenostavljenimi pravili za lastništvo in izposoje na podlagi tistih iz Rusta. Za čiščenje pomnilnika graded modal tipov, se še vedno uporablja avtomatski čistilec, medtem ko se za čiščenje unikatnih in linearnih tipov uporablja Rustov model upravljanja s pomnilnikom.