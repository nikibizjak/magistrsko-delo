\chapter{STG}
\label{ch:stg}

Na tem mestu bomo na kratko opisali delovanje prevajalnika GHC (angl. Glasgow Haskell compiler), ki izvorno kodo napisano v programskem jeziku Haskell prevede v strojno kodo. Pri prevajanju se program transformira v več različnih vmesnih predstavitev (angl. intermediate representation), mi pa se bomo v magistrskem delu osredotočili predvsem na vmesno kodo imenovano STG jezik (angl. Spineless tagless G-Machine language), katerega delovanje bomo podrobneje opisali v razdelku \ref{sec:stg-jezik}.

\subsection{Prevajalnik GHC}
\label{sec:prevajalnik-ghc}

% TODO: Dodaj shemo prevajanja Haskell -> strojna koda

Prevajalnik GHC (angl. Glasgow Haskell compiler) prevajanje iz izvorne kode v programskem jeziku Haskell v strojno kodo izvaja v več zaporednih fazah oziroma modulih. Vsaka faza kot vhod prejme izhod prejšnje, nad njim izvede določeno transformacijo in rezultat posreduje naslednji fazi. Faze glede na njihovo funkcijo v grobem delimo na tri dele. V prednjem delu (angl. front-end) se nad izvorno kodo najprej izvede leksikalna analiza, pri kateri se iz toka znakov, ki predstavljajo vhodni program pridobi abstraktno sintaktično drevo (angl. abstract syntax tree). Nad drevesom se izvede še zaporedje semantičnih analiz pri katerih se preveri ali je program pomensko pravilen. Sem sodi razreševanje imen, pri kateri se razreši vsa imena spremenljivk iz uvoženih modulov v programu in preveri ali so vse spremenljivke deklarirane pred njihovo uporabo. Izvede se še preverjanje tipov, kjer se za vsak izraz izpelje njegov najbolj splošen tip in preveri ali se vsi tipi v programu ujemajo.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\tikzset{
			every node/.append style={text width=1.4cm,execute at begin node=\setlength{\baselineskip}{1em},font=\footnotesize},
			block/.style={draw,rectangle,text width=2cm,align=center,minimum height=1cm,minimum width=2cm},
		}
		
		% Srednji del prevajalnika
		\node[block] (optimizacija) {Optimizacija};
		\node[coordinate, left=2.6cm of optimizacija] (center-levo) {};
		\node[coordinate, right=2.6cm of optimizacija] (center-desno) {};
		
		% Prednji del prevajalnika
		\node[block, above=0.55cm of center-levo] (semanticna-analiza) {Semantična analiza};
		\node[block, above=0.55cm of semanticna-analiza] (razclenjevanje) {Razčlen\-je\-van\-je};
		\node[block, below=0.55cm of semanticna-analiza] (izpeljava-tipov) {Izpeljava tipov};
		\node[block, below=0.55cm of izpeljava-tipov] (razsladenje) {Razsladenje};
		
		% Zadnji del prevajalnika
		\node[block, above=0.55cm of center-desno] (stg-to-cmm) {Izbira \texttt{C--} ukazov};
		\node[block, above=0.55cm of stg-to-cmm] (core-to-stg) {Izbira STG ukazov};
		
		% Moznosti prevajanja C-- -> strojna koda
		\node[block, minimum height=0.6cm, below=0.9cm of stg-to-cmm] (neposredno) {Neposredno};
		\node[block, minimum height=0.6cm, below=0.3cm of neposredno] (gcc) {GCC};
		\node[block, minimum height=0.6cm, below=0.3cm of gcc] (llvm) {LLVM};
		
		% 
		\node[coordinate, left=0.4cm of neposredno.west] (levo-od-neposredno) {};
		\node[coordinate, left=0.4cm of gcc.west] (levo-od-gcc) {};
		\node[coordinate, left=0.4cm of llvm.west] (levo-od-llvm) {};
		\draw[-] (levo-od-neposredno) -- (levo-od-gcc) -- (levo-od-llvm);
		\draw[->] (levo-od-neposredno) -- (neposredno);
		\draw[->] (levo-od-gcc) -- (gcc);
		\draw[->] (levo-od-llvm) -- (llvm);
		
		\node[coordinate, right=0.4cm of neposredno.east] (desno-od-neposredno) {};
		\node[coordinate, right=0.4cm of gcc.east] (desno-od-gcc) {};
		\node[coordinate, right=0.4cm of llvm.east] (desno-od-llvm) {};
		\draw[-] (desno-od-neposredno) -- (desno-od-gcc) -- (desno-od-llvm);
		\draw[-] (neposredno) -- (desno-od-neposredno);
		\draw[-] (gcc) -- (desno-od-gcc);
		\draw[-] (llvm) -- (desno-od-llvm);
		
		\node[coordinate, below=0.55cm of stg-to-cmm] (pod-stg-to-cmm) {};
		\node[coordinate] at (pod-stg-to-cmm -| levo-od-neposredno) (nad-levo-od-neposredno) {};
		\draw[-] (stg-to-cmm) -- (pod-stg-to-cmm) node[pos=0.5,right] {\scriptsize \texttt{C--}} -- (nad-levo-od-neposredno) -- (levo-od-neposredno) ;
		
		\draw[->] (razclenjevanje) -- (semanticna-analiza) node[pos=0.5,right] {\scriptsize AST};
		\draw[->] (semanticna-analiza) -- (izpeljava-tipov) node[pos=0.5,right] {\scriptsize AST};
		\draw[->] (izpeljava-tipov) -- (razsladenje) node[pos=0.5,right] {\scriptsize AST};
		
		\draw[->] (core-to-stg) -- (stg-to-cmm) node[pos=0.5,right] {\scriptsize STG};
		
		% Puscica "Generator vmesne kode" -> "Optimizacija vmesne kode"
		\node[coordinate, left=0.5cm of optimizacija.west] (levo-od-optimizacija) {};
		\node[coordinate] at (razsladenje -| levo-od-optimizacija) (desno-od-razsladenje) {};
		
		\draw[->] (razsladenje.east) -- (desno-od-razsladenje) -- (levo-od-optimizacija) node[pos=0.5,right] {\scriptsize Core} -- (optimizacija);
		
		% Puscica "Optimizacija vmesne kode" -> "Izbira ukazov"
		\node[coordinate, right=0.5cm of optimizacija.east] (desno-od-optimizacija) {};
		\node[coordinate] at (core-to-stg -| desno-od-optimizacija) (levo-od-izbira-ukazov) {};
		
		\draw[->] (optimizacija) -- (desno-od-optimizacija) -- (levo-od-izbira-ukazov) node[pos=1.0,left,align=right] {\scriptsize Core} -- (core-to-stg);
		
		% Vhodna povezava "Zacetek" -> "Leksikalna analiza"
		\node[coordinate, left=2cm of center-levo] (zacetek) {};
		\node[coordinate, left=0.5cm of razclenjevanje] (levo-od-razclenjevanje) {};
		\node[coordinate] at (zacetek -| levo-od-razclenjevanje) (desno-od-zacetek) {};
		
		\draw[->] (zacetek) -- (desno-od-zacetek) -- (levo-od-razclenjevanje) node[pos=0.2,left,text width=0.9cm] {\scriptsize tok\\znakov} -- (razclenjevanje);
		
		% Koncna povezava
		\node[coordinate, right=2cm of center-desno] (konec) {};
		\node[coordinate] at (konec -| desno-od-neposredno) (levo-od-konec) {};
		\draw[->] (desno-od-neposredno) -- (levo-od-konec) -- (konec) node[pos=1,above] {\scriptsize strojna\\koda};
		
		% Locevalne crte
		\node[coordinate, left=0.25cm of levo-od-optimizacija] (sprednji-del-center) {};
		\node[coordinate, above=3.7cm of sprednji-del-center] (sprednji-del-zgoraj) {};
		\node[coordinate, below=3.2cm of sprednji-del-center] (sprednji-del-spodaj) {};
		\draw[dashed] (sprednji-del-zgoraj) -- (sprednji-del-spodaj) node[pos=0,left=0.2cm,text width=2cm,align=right] {prednji del} node[pos=0,right=0.2cm,text width=2cm] {srednji del};
		
		\node[coordinate, right=0.25cm of desno-od-optimizacija] (zadnji-del-center) {};
		\node[coordinate, above=3.7cm of zadnji-del-center] (zadnji-del-zgoraj) {};
		\node[coordinate, below=3.2cm of zadnji-del-center] (zadnji-del-spodaj) {};
		\draw[dashed] (zadnji-del-zgoraj) -- (zadnji-del-spodaj) node[pos=0,right=0.2cm,text width=2cm] {zadnji del};
		
	\end{tikzpicture}
	\caption{Pomembnejše faze prevajalnika Glasgow Haskell compiler}
	\label{fig:shema-ghc}
\end{figure}

Ker je Haskell programski jezik, ki je namenjen ljudem, je precej velik jezik, z veliko različnimi sintaktičnimi oblikami in konstruktorji. Tako lahko npr. programer napiše isto kodo na več različnih načinov. S perspektive piscev prevajalnikov pa to pomeni veliko več dela, saj je potrebno zagotoviti, da se vsi konstrukti v strojno kodo prevedejo pravilno. Za odpravljanje te težave se v zadnjem koraku prednjega dela prevajalnika imenovanem razsladenje (angl. desugarification), sintaktično drevo jezika Haskell pretvori v sintaktično drevo jezika Core. Ta je zelo majhen funkcijski programski jezik, ki temelji na lambda računu, kjub svojem majhnem naboru konstruktov pa še vedno omogoča zapis poljubnega Haskell programa. Naslednje faze tako operirajo nad dosti manjšim jezikom, kar precej poenostavi prevajanje.

Srednji del (angl. middle-end) prevajalnika sestavlja zaporedje optimizacij, ki kot vhod sprejmejo program v Core jeziku in vrnejo izboljšan program v Core jeziku. Rezultat niza optimizacij se posreduje zadnjemu delu (angl. back-end) prevajalnika, ki poskrbi za prevajanje Core jezika v strojno kodo, ki se lahko neposredno izvaja na procesorju. Na tem mestu se Core jezik prevede v STG jezik, ta pa se nato prevede v programski jezik \texttt{C--}. Slednji je podmnožica programskega jezika C in ga je mogoče v strojno kodo prevesti na tri načine: neposredno ali z enim izmed prevajalnikov LLVM ali GCC. Prednost take vrste prevajanja je v večji prenosljivosti programov, saj znata LLVM in GCC generirati kodo za večino obstoječih procesorskih arhitektur, poleg tega pa imata vgrajene še optimizacije, ki pohitrijo delovanje izhodnega programa.

\subsection{STG jezik}
\label{sec:stg-jezik}

Lene funkcijske programske jezike najpogosteje implementiramo s pomočjo redukcije gra\-fa~\cite{peyton1987implementation}. Eden izmed načinov za izvajanje redukcije je abstraktni STG stroj (angl. Spineless Tagless G-machine)~\cite{jones1992implementing}, ki definira in zna izvajati majhen funkcijski programski jezik STG. STG stroj in jezik se uporabljata kot vmesni korak pri prevajanju najpopularnejšega lenega jezika Haskell v prevajalniku GHC (Glasgow Haskell Compiler)~\cite{GHC}.

% Kaj sploh je STG stroj in kaj je STG jezik

\subsubsection{Lena evalvacija}

Ena izmed najpomembnejših lastnosti lenih funkcijskih programskih jezikov je njihova nestroga semantika (angl. non-strict semantic). Ta narekuje kako se evalvirajo oziroma računajo argumenti pri klicu funkcije. Pri jezikih z nestrogo semantiko se računanje vrednosti argumentov funkcije ne izvede ob klicu, temveč šele takrat ko se izvaja telo funkcije. Ker se vrednosti argumentov ne izračunajo nemudoma, temveč se računanje zamakne v času dokler funkcija vrednosti arugmenta dejansko ne potrebuje, je taka semantika imenovana tudi za leno.

% TODO: Preveri kako deluje nestroga semantika v knjigi
$$ f \bot = \bot $$

Leno evalvacijo najpogosteje implementiramo s pomočjo zakasnitev (angl. thunks). Te so na pomnilniku predstavljene kot kazalec na kodo, ki izračuna njihovo vrednost. Ob evalvaciji zakasnitve se najprej izračuna njihova vrendost, izračunano vrednost pa se shrani v struktro na pomnilniku, da je ob naslednji evalvaciji ni potrebno ponovno računati. Na tak način se z nestrogo semantiko doseže, da se vsak izraz izračuna \textit{največ enkrat}. Če se argument ne pojavi nikjer v telesu funkcije, se zakasnitve nikoli ne računa, če pa se v telesu pojavi večkrat, se vrednost izračuna enkrat, za vsako nadaljno evalvacijo argumenta pa se preprosto vrne vrednost shranjeno na pomnilniku.

% TODO: Kaj je razlika med eval/apply in push/enter modelom
% Kaj se spremeni, če dodamo enega in drugega
% Katero različico trenutno uporablja Haskell

Nestrogo semantiko je moč implementirati na dva različna načina:

\begin{itemize}
	\itemsep 0em
	\item model potisni in vstopi (angl. push / enter model)
	\item model izračunaj in apliciraj (angl. eval / apply model)
\end{itemize}

Abstraktni STG stroj je zgodovinsko najprej uporabljal model potisni / vstopi~\cite{jones1992implementing}. Trenutna različica STG stroja pa uporablja model evalviraj / apliciraj~\cite{marlow2004making}, saj se je empirično izkazal za bolj učinkovito implementacijo nestroge semantike.

\subsubsection{Definicija jezika}

V sledečem poglavju bomo podali formalno definicijo jezika STG definirano v \cite{marlow2004making}. Od originalne implementacije v \cite{jones1992implementing} se razlikuje po tem, da implementacija ni več brez oznak (angl. tagless), temveč nosi vsak objekt na kopici še dodatno polje z informacijo o njegovi vrsti. Ker je število tipov objektov majhno, se za oznako objekta navadno uporablja kar celoštevilčna vrednost. V originalni implementaciji so bili vsi objekti na kopici predstavljeni enotno, kar je pomenilo bolj kompaktno predstavitev podatkov v pomnilniku, prav tako pa STG stroju ni bilo treba preverjati vrste objektov ob vsakem klicu funkcije. Prednost ponovne uvedbe oznak pa je v tem, da STG stroju ni potrebno vzdrževati dveh ločenih skladov za argumente in vrednosti, kar pa tudi poenostavi delovanje čistilca pomnilnika.
% TODO: Citat

Sledi formalna definicija STG jezika. Pri tem bomo spremenljivke označevali s poševnimi malimi tiskanimi črkami $x, y, f, g$, konstruktorje pa s poševnimi velikimi tiskanimi črkami $C$.
\begin{align*}
	literal \quad \coloneq& \quad \underline{int} \enspace \vert \enspace \underline{double} & \text{primitivne vrednosti}
\end{align*}

% TODO: Kakšen je prevod za boxed? Unboxed?
STG jezik podpira dva primitivna (angl. unboxed) podatkovna tipa: celoštevilske vrednosti in števila s plavajočo vejico. Poleg tega omogoča uvajanje novih algebraičnih podatkovnih tipov. Objekte algebraičnih tipov tvorimo s pomočjo konstruktorjev $C$.
\begin{align*}
	a, v \quad \coloneq& \quad literal \enspace \vert \enspace x & \text{argumenti so atomarni}
\end{align*}

Vsi argumenti pri aplikaciji funkcij in primitivnih operacij so v A-normalni obliki (angl. A-normal form)~\cite{flanagan1993essence}, kar pomeni, da so atomarni (angl. atomic). Tako je vsak argument ali primitivni podatkovni tip ali pa spremenljivka. Pri prevajanju v STG jezik lahko prevajalnik sestavljene argumente funkcij priredi novim spremenljivkam z ovijanjem v \texttt{let} izraz in spremenljivke uporabi kot argumente pri klicu funkcije. Pri tem je potrebno zagotoviti, da so definirane spremenljivke unikatne oziroma, da se ne pojavijo v ovitem izrazu. Aplikacijo funkcije $f \; (\oplus \; x \; y)$ bi tako ovili v \texttt{let} izraz $\texttt{let} \enspace a = \oplus \; x \; y \enspace \texttt{in} \enspace f \enspace a$, s čemer bi zagotovili, da so vsi argumenti atomarni.

\begin{align*}
	k \quad \coloneq& \quad \bullet & \text{neznana mestnost funkcije}\\
	\vert& \quad n & \text{znana mestnost $n \geq 1$}\\
\end{align*}

Prevajalnik lahko med prevajanjem za določene funkcije določi njihovo mestnost (angl. arity), tj. število argumentov, ki jih funkcija sprejme. Ker pa je STG funkcijski jezik, lahko funkcije nastopajo tudi kot argumenti drugih funkcij, zato včasih določevanje mestnosti ni mogoče. Povsem veljavno bi bilo vse funkcije v programu označiti z neznano mestnostjo $\bullet$, a je mogoče s podatkom o mestnosti klice funkcij implementirati bolj učinkovito, zato se med prevajanjem izvaja tudi analiza mestnosti. 

\begin{align*}
	expr \quad \coloneq& \quad a & \text{atom}\\
	\vert& \quad f^k a_1 \dots a_n & \text{klic funkcije ($n \geq 1$)}\\
	\vert& \quad \oplus a_1 \dots a_n & \text{primitivna operacija ($n \geq 1$)}\\
	\vert& \quad \texttt{let} \enspace x = obj \enspace \texttt{in} \enspace e & \text{} \\
	\vert& \quad \texttt{case} \enspace e \enspace \texttt{of} \enspace \{ alt_1; \dots; alt_n \}& \text{} \\
\end{align*}

% TODO: Prevedi saturated / saturirane v zasičene

Pri tem velja, da so vse primitivne operacije \textit{zasičene}, kar pomeni, da sprejmejo natanko toliko argumentov, kot je mestnost (angl. arity) funkcije. Če programski jezik omogoča delno aplikacijo primitivnih funkcij, potem je potrebno take delne aplikacije z $\eta$-dopolnjevanjem razširiti v saturirano obliko. Pri tem delno aplikacijo ovijemo v nove lambda izraze z uvedbo novih spremenljivk, ki se ne pojavijo nikjer v izrazu. Tako npr. izraz \texttt{(+ 3)}, ki predstavlja delno aplikacijo vgrajene funkcije za seštevanje prevedemo v funkcijo $\lambda x . (+ 3 x)$ in s tem zadostimo pogoju saturiranosti.

\begin{align*}
	alt \quad \coloneq& \quad C \enspace x_1 \dots x_n \to expr & \text{algebraična alternativa}\\
	\vert& \quad x \to expr & \text{privzeta alternativa}\\
\end{align*}

Podatkovne objekte na kopici je mogoče ustvarjati le z enim konstruktom, in sicer \texttt{let} izrazom. Ta nam omogoča prirejanje objekta spremeljivki, ki je vidna v telesu \texttt{let} izraza.

% TODO: Ali dodamo tudi naslednje?
% Dodamo najbrž šele potem, ko bomo govorili o konsturktorjih.
% Pomembno se nam zdi še poudariti, da sta pojma oznake objekta na kopici in oznake konstruktorja 

\begin{align*}
	obj \quad \coloneq& \quad \text{FUN}(x_1 \dots x_n \to e) & \text{aplikacija}\\
	\vert& \quad \text{PAP}(f \; a_1 \dots a_n) & \text{delna aplikacija}\\
	\vert& \quad \text{CON}(C \; a_1 \dots a_n) & \text{konstruktor}\\
	\vert& \quad \text{THUNK} \enspace e & \text{zakasnitev}\\
	\vert& \quad \text{BLACKHOLE} & \text{črna luknja}
\end{align*}

Objekt \textsc{FUN} predstavlja funkcijsko ovojnico (angl. closure) z argumenti $x_1, \dots, x_n$ in telesom $e$, ki pa se lahko poleg argumentov $x_i$ sklicuje še na druge proste spremenljivke. Pri tem velja, da je lahko funkcija aplicirana na več kot $n$ ali manj kot $n$ argumentov, tj. je curryrana.
% Andrej Bauer pravi, da je to okej.
% https://twitter.com/andrejbauer/status/621602561368399872

Objekt \textsc{PAP} predstavlja delno aplikacijo (angl. partial application) funkcije $f$ na argumente $x_1, \dots, x_n$. Pri tem je zagotovljeno, da bo $f$ objekt tipa \textsc{FUN}, katerega mestnost bo \textit{vsaj} $n$.

Objekt \textsc{CON} predstavlja saturirano aplikacijo konstruktorja $C$ na argumente $a1, \dots a_n$. Pri tem je število argumentov, ki jih prejme konstruktor natančno enako številu parametrov, ki jih zahteva.

Objekt \textsc{THUNK} predstavlja zakasnitev izraza $e$. Kadar se vrednost izraza uporabi, tj. kadar se izvede \texttt{case} izraz, se izračuna vrednost $e$, \textsc{THUNK} objekt na kopici pa se nato posodobi s preusmeritvijo (angl. indirection) na vrednost $e$. Pri evalvaciji zakasnitve se objekt \textsc{THUNK} na kopici zamenja z objektom \textsc{BLACKHOLE}, s čemer se preprečuje puščanje pomnilnika~\cite{jones1992tail} in neskončnih rekurzivnih struktur. Objekt \textsc{BLACKHOLE} se lahko pojavi le kot rezultat evalvacije zakasnitve, nikoli pa v vezavi v \texttt{let} izrazu.