\section{Rustov model lastništva}

Programski jezik Rust je namenjen nizkonivojskemu programiranju, tj. programiranju sistemske programske opreme. Kot tak mora omogočati hitro in predvidljivo sproščanje pomnilnika, zato avtomatični čistilnik pomnilnika ne pride v poštev. Rust namesto tega implementira model lastništva~\cite{klabnik2023rust}, pri katerem zna med \textit{prevajanjem} s posebnimi pravili zagotoviti, da se pomnilnik objektov na kopici avtomatično sprosti, kadar jih program več ne potrebuje. Po hitrosti delovanja se tako lahko kosa s programskim jezikom C, pri tem pa zagotavlja varnejše upravljanje s pomnilnikom kot C.

Rust doseže varnost pri upravljanju pomnilnika s pomočjo principa izključitve (angl. exclusion
principle)~\cite{Jung}. V poljubnem trenutku za neko vrednost na pomnilniku velja natanko ena izmed dveh možnosti:

\begin{itemize}
	\itemsep 0em
	\item Vrednost lahko \textit{spreminjamo} preko \textit{natanko enega} unikatnega kazalca
	\item Vrednost lahko \textit{beremo} preko poljubno mnogo kazalcev
\end{itemize}

V nadaljevanju si bomo na primerih ogledali principa premika in izposoje v jeziku Rust. V vseh primerih bomo uporabljali terko \texttt{Complex}, ki predstavlja kompleksno število z dvema celoštevilskima komponentama in je definirana kot \mintinline{rust}{struct Complex(i32, i32)}.

\subsection{Premik}

Eden izmed najpomembnejših konceptov v Rustu je lastništvo. Ta zagotavlja, da si vsako vrednost na pomnilniku lasti natanko ena spremenljivka. Ob prirejanju, tj. izrazu \mintinline{rust}|let x = y|, pride do \textit{premika} vrednosti na katero kaže spremenljivka \texttt{y} v spremenljivko \texttt{x}. Po prirejanju postane spremenljivka \texttt{y} neveljavna in se nanjo v nadaljevanju programa ni več moč sklicevati. Kadar gre spremenljivka, ki si lasti vrednost na pomnilniku izven dosega (angl. out-of-scope), lahko tako Rust ustrezno počisti njen pomnilnik. Naslednji primer prikazuje program, ki se v Rustu ne prevede zaradi težav z lastništvom.

\begin{rust-failure}
let number = Complex(0, 1);
let a = number;
let b = number;  // Napaka: use of moved value: `number`
\end{rust-failure}

Spremenljivka \texttt{a} prevzame lastništvo nad vrednostjo na katero kaže spremenljivka \texttt{number}, tj. strukturo \mintinline{rust}|Complex(0, 1)|. Ob premiku postane spremenljivka \texttt{number} neveljavna, zato pri ponovnem premiku v spremenljivko \texttt{b}, prevajalnik javi napako.

Pravila lastništva~\cite{klabnik2023rust} so v programskem jeziku Rust sledeča:

\begin{itemize}
	\itemsep 0em
	\item Vsaka vrednost ima lastnika.
	\item V vsakem trenutku je lahko lastnik vrednosti le eden.
	\item Kadar gre lastnik izven dosega (angl. out-of-scope), je vrednost spro\-šče\-na.
\end{itemize}

Rust v fazi analize premikov (angl. move check) preveri veljavnost pravil in na ustrezna mesta doda ukaze za sproščanje pomnilnika. Ker si vsako vrednost lasti natanko ena spremenljivka, lahko vrednost sprostimo takoj, ko gre ta izven dosega.

\subsubsection{Funkcije}

Kadar je spremenljivka uporabljena v argumentu pri klicu funkcije, je vrednost spremenljivke premaknjena v funkcijo. Če se vrednost spremenljivke uporabi za sestavljanje rezultata funkcije, potem je vrednost ponovno premaknjena iz funkcije in vrnjena klicatelju. Naslednji primer prikazuje identiteto implementirano v Rustu. Pri klicu funkcije, je vrednost spremenljivke \texttt{number} premaknjena v klicano funkcijo, ker pa je ta uporabljena pri rezultatu funkcije, je vrednost ponovno premaknjena v spremenljivko \texttt{a} v klicatelju.

\begin{rust-success}
fn identiteta(x: Complex) -> Complex { x }

let number = Complex(0, 1);
let a = identiteta(number);
\end{rust-success}

V naslednjem primeru funkcija \texttt{prepisi} prevzame lastništvo nad vrednostjo \mintinline{rust}|Complex(0, 1)|, vrne pa novo vrednost \mintinline{rust}|Complex(2, 1)|, pri čemer ne uporabi argumenta funkcije. Funkcija \texttt{prepisi} je tako odgovorna za čiščenje pomnilnika vrednosti argumenta.

\begin{rust-success}
fn prepisi(x: Complex) -> Complex { Complex(2, 1) }

let number = Complex(0, 1);
let a = prepisi(number);
\end{rust-success}

%Zaradi zgornjih treh pravil lahko lastništvo v Rustu predstavimo kot drevo, kjer so listi vrednosti, vozlišča spremenljivke, povezava $u \to v$ pa označuje, da je spremenljivka $u$ lastnik spremenljivke $v$. Kadar gre spremenljivka $x$ izven dosega, lahko sprostimo njen pomnilnik in pomnilnik vseh vozlišč, ki si jih lasti, tj. celotno poddrevo katerega koren je spremenljivka $x$. Pri premiku \mintinline{rust}{let y = x}, pride do spremembe lastništva. Spremenljivka $y$ prevzame lastništvo nad vsemi vrednostmi in spremenljivkami, ki si jih je prej lastila spremenljivka $x$, prav tako pa postane spremenljivka $x$ na tem mestu neveljavna.

\subsection{Izposoja}

Drugi koncept, ki ga definira Rust je \textit{izposoja}. Ta omogoča \textit{deljenje} (angl. aliasing) vrednosti na pomnilniku. Izposoje so lahko spremenljive (angl. mutable) \texttt{\&mut x} ali nespremenljive (angl. immutable) \texttt{\&x}. V danem trenutku je lahko ena spremenljivka izposojena nespremenljivo oziroma samo za branje (angl. read-only) večkrat, spremenljivo pa natanko enkrat. Preverjanje veljavnosti premikov se v Rustu izvaja v fazi analize izposoj (angl. borrow checker), v kateri se zagotovi, da reference ne živijo dlje od vrednosti na katero se sklicujejo, prav tako pa poskrbi, da je lahko vrednost ali izposojena enkrat spremenljivo ali da so vse izposoje nespremenljive.

Naslednji primer se v Rustu uspešno prevede, ker sta obe izposoji nespremenljivi. Vrednosti spremenljivk \texttt{a} in \texttt{b} lahko le beremo, ne moremo pa jih spreminjati.

\begin{rust-success}
let number = Complex(2, 1);
let a = &number;
let b = &number;
\end{rust-success}

Zaradi principa izključitve je v Rustu prepovedano ustvariti več kot eno spremenljivo referenco na objekt. V primeru, da bi bilo dovoljeno ustvariti več spremenljivih referenc, bi namreč lahko več niti hkrati spreminjalo in bralo vrednost spremenljivke, kar krši pravila varnosti pomnilnika, saj lahko privede do \komentar{težav s sinhronizacijo?} (angl. data races). V naslednjem primeru skušamo ustvariti dve spremenljivi referenci, zaradi česar prevajalnik ustrezno javi napako.

\begin{rust-failure}
let mut number = Complex(1, 2);
let a = &mut number;
let b = &mut number;  // Napaka: cannot borrow `number` as mutable
                      // more than once at a time
\end{rust-failure}

Prav tako v Rustu ni veljavno ustvariti spremenljive reference na spremenljivko, dokler nanjo obstaja kakršnakoli druga referenca. V nasprotnem primeru bi lahko bila vrednost v eni niti spremenjena, medtem ko bi jo druga nit brala.

\begin{rust-failure}
let mut number = Complex(0, 0);
let a = &number;
let b = &mut number;  // Napaka: cannot borrow `number` as mutable
                      // because it is also borrowed as immutable
\end{rust-failure}

%\subsubsection{Ponovna izposoja}
%
%\begin{rust-success}
%let number = Complex(2, 1);
%let a = &number;
%let b = *a;
%\end{rust-success}

\subsubsection{Življenjske dobe}

Kot smo že omenili, analiza izposoj v Rustu zagotovi, da v danem trenutku na eno vrednost kaže le ena spremenljiva referenca ali da so vse reference nanjo nespremenljive. Prav tako pa mora prevajalnik v tej fazi zagotoviti, da nobena referenca ne živi dlje od vrednosti, ki si jo izposoja. To doseže z uvedbo \textit{življenjskih dob} (angl. lifetimes), ki predstavljajo časovne okvirje, v katerih so reference veljavne. Prevajalnik navadno življenjske dobe določi implicitno s pomočjo dosegov (angl. scopes). Vsak ugnezden doseg uvede novo življenjsko dobo, za katero velja, da živi največ tako dolgo kot starševski doseg. Kadar se namreč izvedejo vsi stavki v dosegu, bo pomnilnik vseh spremenljivk, definiranih v dosegu, sproščen.

Naslednji primer prikazuje program, ki se v Rustu ne prevede zaradi težav z življenjskimi dobami. Program je sestavljen iz dveh dosegov:
\begin{itemize}
	\itemsep 0em
	\item Spremenljivka \texttt{outer} živi v zunanjem dosegu, prevajalnik ji dodeli življenjsko dobo \texttt{'a}.
	\item Nov blok povzroči uvedbo novega dosega z življenjsko dobo \texttt{'b}, zato prevajalnik spremenljivki \texttt{inner} določi življenjsko dobo \texttt{'b}.
\end{itemize}

\begin{rust-failure}
let outer;
{
    let inner = 3;
    outer = &inner;  // Napaka: `inner` does not live
                     // long enough
}
\end{rust-failure}

Ker je notranji doseg uveden znotraj zunanjega dosega, si prevajalnik tudi označi, da je življenjska doba \texttt{'a} daljša od dobe \texttt{'b}. To pomeni, da bodo vse spremenljivke, ki so definirane znotraj notranjega dosega živele manj časa od spremenljivk definiranih v zunanjem dosegu. V našem primeru bi tako spremenljivka \texttt{outer} kazala na spremenljivko, ki je že bila uničena, s čemer pa bi v program uvedli viseč kazalec, kar pa krši varnostni model jezika, zato Rust vrne napako.

\komentar{Najbrž bi bilo tukaj smiselno razložiti še, da Rust ne zna sam izračunati \textit{vseh} življenjskih dob in da jih moramo v primeru funkcij z več argumenti, definirati ročno.}
% kdaj pa jih rabi eksplicitno?

% Non-lexical lifetimes
Od leta 2022 Rust podpira neleksikalne življenjske dobe (angl. non-lexical lifetimes)~\cite{Matsakis_2018, Matsakis_et_al_2022}, pri katerih se preverjanje izposoj in premikov izvaja nad grafom poteka programa (angl. control flow graph) namesto nad abstraktnim sintaktičnim drevesom programa~\cite{Oxide, StackedBorrows}. Prevajalnik zna s pomočjo neleksikalnih življenjskih dob dokazati, da sta dve zaporedni spremenljivi izposoji varni, če ena izmed njih ni nikjer uporabljena. Na tak način Rust zagotovi bolj drobnozrnat (angl. fine grained) pogled na program, saj prevajalnik vrača napake ob manj veljavnih programih.

Potrebno je poudariti, da bi se vsi primeri v tem poglavju v trenutni različici Rusta zaradi neleksikalnih življenjskih dob vseeno prevedli. Primere smo namreč zaradi boljšega razumevanja in jedrnatosti prikaza nekoliko poenostavili. Zato za vse primere v tem poglavju predpostavljamo, da so tako premaknjene, kot tudi izposojene spremenljivke v nadaljevanju programa še nekje uporabljene.

% Formalizacije Rusta
Kljub temu, da Rust v svoji dokumentaciji~\cite{klabnik2023rust} zagotavlja, da je njegov model upravljanja s pomnilnika varen, pa njegovi razvijalci niso nikoli uradno formalizirali niti njegove operacijske semantike, niti sistema tipov, niti modela za prekrivanje (angl. aliasing model). V literaturi se je tako neodvisno uveljavilo več modelov, ki skušajo čimbolj natančno formalizirati semantiko premikov in izposoj. Model Patina~\cite{reed2015patina} formalizira delovanje analize izposoj v Rustu in dokaže, da velja izrek o varnosti (angl. soundness) za varno (angl. safe) podmnožico jezika Rust. Model RustBelt~\cite{10.1145/3158154} poda prvi formalen in strojno preverjen dokaz o varnosti za jezik, ki predstavlja realistično podmnožico jezika Rust. Model Stacked borrows~\cite{StackedBorrows} definira operacijsko semantiko za dostopanje do pomnilnika v Rustu in model za prekrivanje (angl. aliasing model) in ga strojno dokaže. Model Oxide~\cite{Oxide} je formalizacija Rustovega sistema tipov in je tudi prva semantika, ki podpira tudi neleksikalne življenjske dobe. 