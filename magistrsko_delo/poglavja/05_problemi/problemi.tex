\chapter[Lastništvo in izposoja v STG]{Težave pri prenosu lastništva in življenjskih dob v STG}
\label{ch:problemi}

Za potrebe naše magistrske naloge smo pripravili simulator abstraktnega STG stroja\footnote{Dostopen na naslovu \url{https://github.com/nikibizjak/magistrsko-delo}.}, ki zna razčleniti kodo, napisano v STG jeziku in jo izvesti. Sintaksa STG jezika temelji na tisti iz originalnega članka~\cite{marlow2004making}, za izračun aplikacije funkcij je uporabljen model izračunaj in uporabi, pri preverjanju pravilnosti implementacije pa smo si pomagali s spletnim simulatorjem STG jezika\footnote{Dostopen na naslovu \url{https://github.com/MrTipson/webstg}.}. Namen našega dela je bil v simulator dodati analizo premikov in izposoj, kot jo poznamo v Rustu. Za osnovo smo vzeli \emph{len} funkcijski programski jezik Blang~\cite{turk2022len}, ki naj bi za upravljanje s pomnilnikom že uporabljal model lastništva in izposoje.

% TODO: Manjka še kaj vsebine (ravno 1 odstavek, da pokrije polovico strani zaradi oblikovanja)

\section{Implementiran prevajalnik}
Slika \ref{fig:shema-implementacije} prikazuje zamišljeno strukturo našega prevajalnika. Z odebeljeno pisavo so označene faze, ki smo jih v naš prevajalnik uspešno implementirali. Implementacija vhodni program prebere iz datoteke in v fazi leksikalne in sintaksne analize sestavi abstraktno sintaksno drevo. Nad drevesom se izvedeta dve vrsti semantične analize:
\begin{itemize}
    \itemsep 0em
    \item Pri razreševanju imen (angl. name resolution) prevajalnik preveri, ali so bile vse spremenljivke definirane preden so bile uporabljene, s čimer se zagotovi, da pri izvajanju ne bo prišlo do napak zaradi dostopa do spremenljivk, ki ne bi obstajale.
    \item Pri analizi mestnosti (angl. arity analysis) se pri aplikacijah funkcij $f^k \; a_1 \dots a_n$ za funkcije izračuna njihovo mestnost $k$. Pri sestavljanju abstraktnega sintaksnega drevesa prevajalnik namreč vse aplikacije označi z neznano mestnostjo $f^{\bullet} \; a_1 \dots a_n$. Za funkcije, ki so bile uvedene s pomočjo konstruktorja \textsc{fun}, lahko prevajalnik mestnost določi na podlagi števila parametrov. Za tiste aplikacije funkcij, ki jim mestnosti ni mogoče določiti (npr. funkciji $f$ v izrazu \texttt{apply = FUN(f x -> f x)}), se uporabi neznana mestnost $\bullet$, za izvajanje pa poskrbijo  ustrezna pravila (\ref{eq:stg-exact}, \ref{eq:stg-tcall}, $\dots$) operacijske semantike.
\end{itemize}

Po semantični analizi se začne izvajanje STG programa s pomočjo abstraktnega STG stroja, ki implementira pravila operacijske semantike, opisana v poglavju \ref{sec:stg-operacijska-semantika}. Implementacija sestoji iz izraza, ki ga trenutno računamo, sklada, ki hrani kontinuacije in kopice, na kateri so shranjeni \textit{objekti}, ki jih STG stroj obdeluje (tj. objekti \object{thunk}, \object{fun}, \object{con}, \object{pap}, \object{blackhole} in \object{indirection}). Vsak objekt na kopici vsebuje še okolje (angl. environment), ki imena spremenljivk slika v naslove povezanih objektov na kopici. Prevajalnik zna okolja optimizirati tako, da v njih hrani le nujno potrebne spremenljivke, tj. spremenljivke, ki so v telesu objekta proste (angl. free variables).

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{
			every node/.append style={text width=1.4cm,execute at begin node=\setlength{\baselineskip}{1em},font=\footnotesize},
			block/.style={draw,rectangle,text width=2cm,align=center,minimum height=1cm,minimum width=2cm},
		}

        \node[block] (lexer) {\textbf{Leksikalna analiza}};
		\node[block, below=0.5cm of lexer] (parser) {\textbf{Sintaksna analiza}};
		
		\node[coordinate, left=0.5cm of lexer.west] (levo-od-lexer) {};

        \node[coordinate, right=2.2cm of lexer] (center) {};
		
		% \node[block,right=1cm of parser] (borrow-checker) {Analiza izposoj};
        \node[block,below=0.25cm of center] (borrow-checker) {\textbf{Analiza premikov}};
        \node[block, above=0.5cm of borrow-checker] (arity-analysis) {\textbf{Analiza mestnosti}};
		\node[block, above=0.5cm of arity-analysis] (name-resolution) {\textbf{Raz\-re\-še\-van\-je imen}};
		\node[block, below=0.5cm of borrow-checker] (move-checker) {Analiza izposoj};
		\node[block, right=2.2cm of center] (interpreter) {\textbf{Abstraktni stroj STG'}};
		
		\node[coordinate, right=0.5cm of interpreter.east] (desno-od-interpreter) {};
		
		% Input arrow
		\draw[->] (levo-od-lexer) -- (lexer) node[above, pos=-0.25,align=center] {\scriptsize tok\\znakov};
		
		% Output arrow
		\draw[->] (interpreter) -- (desno-od-interpreter) node[above,pos=1.25,align=center] {\scriptsize rezultat};
		
		% Parser -> name resolution arrow
		\node[coordinate, right=0.3cm of parser.east] (desno-od-parser) {};
		\node[coordinate] at (desno-od-parser |- name-resolution) (levo-od-name-resolution) {};	
        \draw[->] (lexer) -- (parser);
		\draw[->] (parser) -- (desno-od-parser) -- node[align=center,sloped,anchor=center,above,pos=0.75] {\scriptsize STG} (levo-od-name-resolution) -- (name-resolution);
		
		% Move checker -> abstract STG machine arrow
		\node[coordinate, left=0.3 of interpreter.west] (levo-od-interpreter) {};
		\node[coordinate] at (move-checker -| levo-od-interpreter) (desno-od-move-checker) {};
		\draw[->] (move-checker.east) -- (desno-od-move-checker) -- node[align=center,sloped,anchor=center,below,pos=0.25] {\scriptsize STG'} (levo-od-interpreter) -- (interpreter);
		
		% 
		\draw[->] (name-resolution) -- node[pos=0.5,right] {\scriptsize STG} (arity-analysis);
        \draw[->] (arity-analysis) -- node[pos=0.5,right] {\scriptsize STG} (borrow-checker);
		\draw[->] (borrow-checker) -- node[pos=0.5,right] {\scriptsize STG'} (move-checker);
		
		% Oznake za semantično analizo
		\node[coordinate, above=0.4 of name-resolution.north] (top) {};
		\node[coordinate, below=0.4 of move-checker.south] (bottom) {};
		
		\node[coordinate, left=0.5 of borrow-checker.west] (semanticna-analiza-levo) {};
		\node[coordinate, right=0.5 of borrow-checker.east] (semanticna-analiza-desno) {};
		
		\node[coordinate] at (semanticna-analiza-levo |- top) (semanticna-analiza-levo-zgoraj) {};
		\node[coordinate] at (semanticna-analiza-levo |- bottom) (semanticna-analiza-levo-spodaj) {};
		
		\node[coordinate] at (semanticna-analiza-desno |- top) (semanticna-analiza-desno-zgoraj) {};
		\node[coordinate] at (semanticna-analiza-desno |- bottom) (semanticna-analiza-desno-spodaj) {};
		
		\draw[-,dashed] (semanticna-analiza-levo-zgoraj) -- (semanticna-analiza-levo-spodaj) -- (semanticna-analiza-desno-spodaj) -- (semanticna-analiza-desno-zgoraj) -- (semanticna-analiza-levo-zgoraj);
		
		\path (semanticna-analiza-levo-zgoraj) -- node[above=0.1,align=center,text width=3cm] {Semantična analiza} (semanticna-analiza-desno-zgoraj);
		
	\end{tikzpicture}
	\caption{Predvidena struktura implementiranega prevajalnika}
	\label{fig:shema-implementacije}
\end{figure}

\section{Vrstni red izračuna izrazov}

V poglavju \ref{sec:leni-izracun} smo omenili, da programske jezike glede na implementirano semantiko računanja izrazov v grobem ločimo na neučakane in lene. V naslednjem poglavju si bomo na primeru ogledali, kako to vpliva na sam vrstni red izvajanja operacij v programu.

\subsection{Neučakanost jezika Rust}

Programski jezik Rust implementira strogo semantiko, kar pomeni, da se pri klicu funkcije najprej izračunajo vrednosti argumentov, ki so nato ob klicu posredovane v telo funkcije. Prav tako se zaradi neučakanosti pri prirejanju v spremenljivko (tj. izrazu \mintinline{rust}{let lhs = rhs;}) najprej do konca izračuna vrednost desnega dela prirejanja, torej \textit{rhs}. V splošnem velja, da če se stavek $s_1$ v programu pojavi leksikalno pred stavkom $s_2$, potem se bo stavek $s_1$ zagotovo izvedel pred $s_2$.

V tem poglavju bomo predpostavljali, da se dosegi spremenljivk računajo glede na leksikalen doseg. Kot smo že omenili v poglavju \ref{ch:rust}, zna Rust življenjske dobe računati neleksikalno. To pomeni, da se pri analizi živ\-ljenj\-skih dob izvede še analiza živosti spremenljivk (angl. liveness analysis), s pomočjo katere se lahko življenjske dobe določijo bolj natančno. Posledično imajo lahko spremenljivke krajšo življenjsko dobo kot funkcija, ki jih je ustvarila. V tem poglavju bomo predpostavljali, da je spremenljivka živa od njene uvedbe do konca bloka, v katerem je bila deklarirana, oziroma do prvega (in tudi edinega) premika spremenljivke.

Spodnji primer prikazuje program v Rustu, ki vsebuje tri zaporedne klice funkcij. Zaradi neučakanosti jezika se bodo stavki zagotovo izvajali glede na vrstni red, v katerem so zapisani. Tako se bo klic funkcije \var{mul} zagotovo \emph{v celoti} izvedel pred klicem \var{div}, ta pa se bo zagotovo izvedel pred klicem \var{add}.

\begin{primer}[ht]
\centering
\begin{rust-success}
fn izracunaj() -> i32 {
    let a = mul(6, 2);
    let b = div(8, 2);
    let r = add(b, a);
    return r;
}
\end{rust-success}
\caption{Vrstni red izvajanja operacij v Rustu}
\label{pr:rust-vrstni-red-operacij}
\end{primer}


% Življenjske dobe.


% Če predpostavimo, da se v Rustu življenjske dobe računajo leksikalno.
Ker je vrstni red operacij natanko določen, je zelo preprosto izračunati tudi življenjske dobe. V primeru \ref{pr:rust-vrstni-red-operacij} ima spremenljivka \var{a} zagotovo daljšo življenjsko dobo od spremenljivke \var{b}, saj je bila deklarirana pred uvedbo spremenljivke \var{b}. Ker bi se spremenljivka \var{b} lahko sklicevala na spremenljivko \var{a}, je potrebno zagotoviti, da spremenljivka \var{a} živi vsaj toliko časa kot \var{b}, kar pomeni, da je življenjska doba spremenljivke \var{a} večja od \var{b}.

% Opis kako bi se to izvedlo v lenem izračunu
\subsection{Lenost jezika STG}

V prejšnjem poglavju smo si ogledali primer \ref{pr:rust-vrstni-red-operacij}, ki prikazuje vrstni red izvajanja operacij v jeziku Rust. Primer \ref{pr:glavni-primer} (iz poglavja \ref{sec:stg-primer}) prikazuje enak program, implementiran v lenem programskem jeziku STG. Pri tem se na kopici najprej ustvarijo trije novi objekti z neizračunanimi izrazi \object{thunk}. Po definiciji jezika STG se objekti ustvarijo v takem zaporedju, kot se v programu pojavijo, a se tukaj, za razliko od Rusta, pri prirejanju še ne izračunajo. Izračun se sproži šele, ko se začne izračun izraza \var{r} v telesu \texttt{let} izraza. Pri tem se začne izračun zakasnitve \texttt{THUNK(add b a)}, ki glede na definicijo funkcije \var{add} najprej izračuna levi, nato pa še desni izraz. Pri neučakanem računu se vrednosti spremenljivk izračunajo v vrstnem redu, kot so bile definirane, tj. \var{a}, \var{b}, \var{r}, medtem ko se pri lenem izračunu vrednosti izračunajo v vrstnem redu \var{b}, \var{a}, \var{r}. Pri jezikih z lenim izračunom je vrstni red računanja odvisen od samih implementacij funkcij, kar oteži semantične analize v prevajalniku.

\section{Analiza premikov v STG jeziku}
\label{sec:analiza-premikov}

V poglavju \ref{sec:stg-definicija} smo videli, da jezik STG sestoji iz le peščice operacij: atomarnih operacij, aplikacij funkcij in primitivnih operacij, izraza \texttt{let}, ki na kopici ustvari nove objekte in izraza \texttt{case}, ki sproži izračun zakasnitve (angl. forcing a thunk) in glede na rezultat izvede eno izmed možnih alternativ.

Pri izrazu \texttt{let} se najprej na kopici ustvari nov objekt, nato pa se izvede še telo izraza. Primer \ref{pr:vrstni-red-let-izrazov} prikazuje dva zaporedna \texttt{let} izraza, ki ustvarita spremenljivki \var{a} in \var{b}. S pravili izračuna zakasnitev je zagotovljeno, da se bo objekt, na katerega kaže spremenljivka \var{a}, na kopici ustvaril \emph{pred} objektom, na katerega kaže spremenljivka \var{b}.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik \cmark}
main = THUNK(
    let a = THUNK(...) in -- let1
    let b = THUNK(...) in -- let2
        -- body2
)
\end{code-box}
\caption{Vrstni red izvajanja \texttt{let} izrazov}
\label{pr:vrstni-red-let-izrazov}
\end{primer}


A ker je jezik len, je vrstni red računanja vrednosti objektov \var{a} in \var{b} odvisen od samega izraza v telesu \texttt{body2}. Lahko se zgodi, da sta spremenljivki uporabljeni kot argumenta pri klicu funkcije, ki ju izračuna v poljubnem vrstnem redu (oziroma ju sploh ne), zaradi česar je pri prevajanju skoraj nemogoče predvideti, v katerem vrstnem redu se bodo objekti izračunali.

\subsection{Formalna definicija analize premikov}
% Ideja: Kaj če lastništvo prenašamo kadar se objekt ustvari?
Zgoraj omenjena lastnost \texttt{let} izraza nam da idejo za implementacijo analize premikov (angl. move check), ki zna preveriti, če na vsak objekt na kopici kaže natanko ena referenca. Pri tem upoštevamo, da se las\-tni\-štvo prenese ob \textit{ustvarjanju} objekta na kopici. Tako analizo lahko izvedemo leksikalno nad abstraktnim sintaksnim drevesom v času prevajanja.

V splošnem pravila analize premikov zapišemo kot
\begin{equation*}
    \langle \Delta, \, expr \rangle \leadsto \Delta'
    \label{eq:analiza-premikov-oblika-pravil}
    \rlap{\quad\mbox{,}}
\end{equation*}
kjer je $expr$ izraz v STG jeziku, $\Delta$ pa množico trenutno veljavnih spremenljivk. Ta vsebuje vse spremenljivke, do katerih lahko v danem trenutku dostopamo, tj. spremenljivk, ki še niso bile premaknjene. Rezultat analize je nova množica spremenljivk, ki so veljavne po izvajanju izraza $expr$. Če se izraz $expr$ ne ujema z nobenim izmed pravil, prevajalnik javi napako.

Pri analizi premikov primitivnih vrednosti velja pravilo
\begin{equation}
\infers[int]{}{
    \langle \Delta , \, \texttt{n\#} \rangle
}{
    \Delta
}
\label{eq:int}
\end{equation}
Pri tem se kontekst $\Delta$ ne spremeni, saj izraz ne uporabi nobene spremenljivke in tako ne prenese lastništva.

Pri uporabi spremenljivke velja pravilo
\begin{equation}
\infers[var]{
    x \in \Delta
}{
    \langle \Delta , \, x \rangle
}{
	\Delta \setminus \{ x \}
}
\label{eq:var}
\end{equation}
Pri uporabi spremenljivke pride do prenosa lastništva. Spremenljivka $x$ v nadaljevanju ni več veljavna, zato je odstranjena s konteksta $\Delta$. Pogoj $x \in \Delta$ zagotavlja, da lahko v izrazu dostopamo le do veljavnih spremenljivk. Če spremenljivka ne nastopa kot element množice $\Delta$, se izraz ne ujema z nobenim izmed pravil, zato prevajalnik javi napako.

Pri analizi premikov aplikacije funkcij velja
\begin{equation}
\infers[app]{
    f \in \Delta \qquad \Delta_0 \coloneqq \Delta \setminus \{ f \} \qquad \langle \Delta_0 , \, a_1 \rangle \leadsto \Delta_1 \qquad \dots \qquad \langle \Delta_{n-1} , \, a_n \rangle \leadsto \Delta_n
}{
    \langle \Delta , \, f^k \, a_1 \dots a_n \rangle
}{
	\Delta_n
}
\label{eq:app}
\end{equation}
Ker je $f$ spremenljivka, aplikacija prevzame lastništvo nad njo, prav tako pa se vrednosti argumentov premaknejo v samo funkcijo. Pri klicu funkcije namreč parametrom $x_1, \dots, x_n$ implicitno priredimo vrednosti argumentov $a_1, \dots, a_n$ in jih s tem \emph{premaknemo} v telo funkcije.

Podobno kot aplikacijo funkcij obravnavamo tudi primitivne operacije. Zanje velja pravilo
\begin{equation}
\infers[primop]{
    \langle \Delta , \, a_1 \rangle \leadsto \Delta_1 \qquad \langle \Delta_1 , \, a_2 \rangle \leadsto \Delta_2 \qquad\dots \qquad \langle \Delta_{n-1} , \, a_n \rangle \leadsto \Delta_n
}{
    \langle \Delta , \, f^k \, a_1 \dots a_n \rangle
}{
	\Delta_n
}
\label{eq:primop}
\end{equation}
Za primitivne operacije predpostavimo, da se njihov pomnilnik ne čisti in so lahko tako v programu uporabljene poljubno mnogokrat. Pri uporabi primitivnih operacij torej premaknemo le argumente.

Pri tem je potrebno poudariti, da s praviloma \ref{eq:app} in \ref{eq:primop} uvedemo vrstni red obdelave argumentov, ti se namreč v kontekst dodajo oziroma iz njega odstranijo od leve proti desni, ne glede na to, ali so v telesu funkcije sploh uporabljeni. Z analizo premikov tako v STG jezik uvedemo vrstni red prenosa argumentov.

Pri analizi premikov za \texttt{let} izraze velja
\begin{equation}
\infers[let]{
    \langle \Delta , \, \textit{obj} \, \rangle \leadsto \Delta_1
    \qquad
    \langle \Delta_1 \cup \{ x \} , \, e \rangle \leadsto \Delta_2
}{
    \langle \Delta , \, \texttt{let} \enspace x = \textit{obj} \enspace \texttt{in} \enspace e \rangle
}{
	\Delta_2
}
\label{eq:let}
\end{equation}
Pri tem se najprej na kopici ustvari nov objekt $x$, ki lahko prevzame lastništvo nad spremenljivkami v trenutnem kontekstu. Izraz \texttt{let} ni rekurziven, zato v kontekst $\Delta$ ne dodamo spremenljivke $x$. Nadaljujemo z analizo telesa \texttt{let} izraza, ki lahko premakne vse tiste spremenljivke, ki še niso bile premaknjene v novonastali objekt (tj. ravno spremenljivke v kontekstu $\Delta_1$) in spremenljivko, ki je bila definirana v \texttt{let} izrazu (tj. spremenljivko $x$).

Za \texttt{case} izraz velja pri analizi premikov pravilo
\begin{equation}
\infers[case]{
    \langle \Delta , \, e \rangle \leadsto \Delta' \qquad \langle \Delta' , \, \textit{alt}_1 \rangle \leadsto \Delta_1 \qquad \dots \qquad \langle \Delta' , \, \textit{alt}_n \rangle \leadsto \Delta_n
}{
    \langle \Delta , \, \texttt{case} \; e \; \texttt{of} \; \{ \textit{alt}_1; \dots; \textit{alt}_n \} \rangle
}{
	\Delta_1 \cap \dots \cap \Delta_n
}
\label{eq:case}
\end{equation}
Pri tem se najprej izvede izraz $e$ (angl. scrutinee), ki lahko prevzame lastništvo nad spremenljivkami v kontekstu $\Delta$. Spremenljivke, ki niso bile premaknjene v izrazu $e$ (tj. spremenljivke v množici $\Delta'$), so lahko premaknjene v telesu \texttt{case} izraza, tj. eni izmed $n$ možnih alternativ. Ker se vedno izvede \emph{natanko ena} izmed alternativ, lahko upoštevamo, da lahko alternative premaknejo iste spremenljivke. V novem kontekstu so torej vse tiste spremenljivke, ki niso bile premaknjene v nobeni izmed alternativ.

V nadaljevanju podamo še pravila za analizo premikov objektov $obj$ in alternativ $alt$. Pri zakasnitvah \object{thunk} velja pravilo
\begin{equation}
\infers[thunk]{
    \langle \Delta , \, e \rangle \leadsto \Delta'
}{
    \langle \Delta , \, \object{thunk}(e) \rangle
}{
	\Delta'
}
\label{eq:thunk}
\end{equation}
Velja torej, da pri zakasnitvah preprosto analiziramo izraz v zakasnitvi.

Za konstruktorje \object{con} v fazi analize premikov velja pravilo
\begin{equation}
\infers[con]{
    \langle \Delta_0 , \, a_1 \rangle \leadsto \Delta_1
    \qquad
    \dots
    \qquad
    \langle \Delta_{n - 1} , \, a_n \rangle \leadsto \Delta_n
}{
    \langle \Delta_0 , \, \object{con}(C \, a_1 \dots a_n) \rangle
}{
	\Delta_n
}
\label{eq:con}
\end{equation}
Konstruktorji prevzamejo lastništvo nad vsemi spremenljivkami, ki se pojavijo kot argumenti.

Pri analizi premikov funkcij \object{fun} velja pravilo
\begin{equation}
\infers[fun]{
    \langle \Delta \cup \{ x_1, \dots, x_n \} , \, e \rangle \leadsto \Delta'
}{
    \langle \Delta , \, \object{fun}(x_1 \dots x_n \to e) \rangle
}{
	\Delta'
}
\label{eq:fun}
\end{equation}
Velja torej, da funkcije v kontekst $\Delta$ uvedejo nove spremenljivke (parametri $x_1, \dots, x_n$), nato pa z analizo premikov nadaljujemo v telesu funkcije.

Objekta \object{pap} in \object{blackhole} se nikoli ne pojavita na desni strani izraza za prirejanje. Uporabljena sta za hranjenje stanja sistema in ju kot taka lahko na kopici ustvari samo izvajalno okolje. Ker se analiza premikov izvaja v času prevajanja, tako pravila za \object{pap} in \object{blackhole} niso potrebna.

Pri analizi premikov algebraične alternative velja
\begin{equation}
\infers[conalt]{
    \langle \Delta \cup \{ x_1, \dots, x_n \} , \, e \rangle \leadsto \Delta'
}{
    \langle \Delta , \, C \enspace x_1 \; \dots \; x_n \to e \rangle
}{
	\Delta'
}
\label{eq:conalt}
\end{equation}

Analizo premikov privzete alternative podaja naslednje pravilo
\begin{equation}
\infers[condef]{
    \langle \Delta \cup \{ x \} , \, e \rangle \leadsto \Delta'
}{
    \langle \Delta , \, x \to e \rangle
}{
	\Delta'
}
\label{eq:condef}
\end{equation}

Pravili za alternative \texttt{case} izraza uvedejo nove spremenljivke (podobno kot pri pravilih \ref{eq:let} in \ref{eq:fun}), ki jih dodamo v kontekst, nato pa nadaljujemo z analizo premikov izraza $e$ v alternativi.

\subsection{Lastništvo objektov}

S pravili analize premikov je v jeziku zagotovljeno, da je vsaka spremenljivka uporabljena \emph{največ enkrat} (tj. nič ali enkrat), kar ustreza sistemu afinih tipov~\cite{pierce2004advanced}. Tak sistem tipov omogoča linearne tipe z dodano zožitvijo. Če program uspešno prestane analizo lastništva, velja, da na vsak objekt na kopici kaže naj\-več en kazalec. V tem poglavju bomo opisali sistem lastništva, ki je uporabljen med samim izvajanjem programa in skrbi za ustrezno čiščenje pomnilnika. Pri sistemu lastništva se z neokvirjenimi (angl. unboxed) vrednostmi ne bomo ukvarjali, ker lahko te navadno spravimo v en register in je posledično njihovo kopiranje zelo preprosto in učinkovito.

Pri sistemu lastništva obravnavamo dva ločena pojma: spremenljivke in objekte. Objekti $obj$ so strukture (oziroma ovojnice) na kopici, ki so bile definirane v poglavju \ref{sec:stg-definicija}. Vsak objekt je lahko ena izmed petih možnosti (\textsc{thunk}, \textsc{fun}, \textsc{con}, \textsc{pap} ali \textsc{blackhole}) in je sestavljen iz kode, ki se izvede ob izračunu objekta in okolja, v katerem se hranijo vrednosti prostih spremenljivk. Pri uvedbi sistema lastništva vsak objekt na kopici razširimo še s seznamom kazalcev na objekte, ki si jih le-ta lasti. V programskem jeziku Blang~\cite{turk2022len} je tak  seznam imenovan za \textit{seznam močnih kazalcev}, zato bomo tako terminologijo uporabljali tudi v našem delu. Med izvajanjem kode objekta lahko pride do prenosa lastništva, pri čemer je potrebno seznam močnih kazalcev dopolniti z novo vrednostjo oziroma kakšen kazalec odstraniti. Kadar se objekt do konca izračuna (npr. ob posodobitvi objekta \textsc{thunk}), se sprosti pomnilnik vseh objektov, na katere kažejo močni kazalci. Pri tem pa si tudi objekti na seznamu močnih kazalcev lastijo druge objekte, zaradi česar je potrebno operacijo sproščanja izvajati rekurzivno: vsak objekt, na katerega kaže kazalec iz seznama močnih kazalcev, najprej sprosti pomnilnik vseh objektov, ki si jih lasti, nato pa odstrani še sam sebe. V učinkoviti implementaciji bi vsak objekt poleg kode za izračun vseboval še kodo za čiščenje pomnilnika, ki bi poskrbela za odstranjevanje vseh vrednosti, ki si jih lasti.

Kadar nek objekt ustvari novo spremenljivko $x$, tj. z \texttt{let} izrazom, se na kopici ustvari nov objekt, njegov naslov pa se shrani v spremenljivko $x$. Ker je objekt spremenljivko ustvaril, je posledično tudi lastnik objekta, na katerega spremenljivka kaže, zato se ob prirejanju v spremenljivko v seznam močnih kazalcev doda še naslov objekta, na katerega spremenljivka kaže.

V nadaljevanju bomo neformalno opisali pravila za prenašanje lastništva. Pri tem bomo upoštevali, da vsaka \emph{uporaba} neke spremenljivke preda lastništvo objekta, na katerega spremenljivka kaže, nekemu drugemu objektu.

\begin{itemize}
    \itemsep 0em
    \item Pri aplikaciji $f^k \: a_1 \dots a_n$ so argumenti atomarni, kar pomeni, da so ali neokvirjene vrednosti, pri katerih se z lastništvom ne ukvarjamo, ali pa spremenljivke, ki kažejo na druge objekte na kopici. Lastništvo objektov, na katere kažejo argumenti $a_1, \dots, a_n$, se preda objektu, na katerega kaže spremenljivka $f$.
    \item Pri primitivnih operacijah $\oplus \: a_1 \dots a_n$ operator $\oplus$ prevzame lastništvo nad objekti, na katere kažejo argumenti $a_1, \dots, a_n$.
    \item Pri izrazu $\texttt{let} \enspace x = obj \enspace \texttt{in} \enspace e$ se na kopici najprej ustvari objekt $obj$, ki prevzame lastništvo nad vsemi prostimi spremenljivkami, ki se v njem pojavijo. Izraz \texttt{let} uvede novo spremenljivko $x$, pri čemer trenutni objekt (tj. objekt, v katerem se stavek \texttt{let} pojavi) prevzame lastništvo nad novo ustvarjenim objektom $obj$. Po prenosu lastništva sledi izračun telesa $e$.
    \item Pri \texttt{case} izrazu se najprej izračuna vrednost izraza $e$, kar lahko vodi do prenosa lastništva. Rezultat izračuna je naslov $v$ konstruktorja \textsc{con}, ki se ujema z eno izmed alternativ. Če so vsi dosedanji izrazi lastništvo predali, ga \texttt{case} izraz prevzame. Trenutnemu objektu se v seznam lastništva dodajo kazalci na vse objekte, ki si jih objekt $v$ lasti. Objekt na katerega kaže $v$, lahko izbrišemo iz pomnilnika, saj nanj zagotovo kaže le kazalec $v$.
\end{itemize}

\subsubsection{Sprememba operacijske semantike}

Operacijsko semantiko je potrebno dopolniti s pravili za čiščenje pomnilnika. V nadaljevanju neformalno opišemo nekaj najpomembnejših sprememb operacijske semantike.

\begin{itemize}
    \itemsep 0em
    \item Pravilo \ref{eq:stg-update} posodobi objekt \textsc{thunk} na kopici s preusmeritvijo \textsc{indirection}, ki kaže na objekt z rezultatom. Ker je pri tem \textsc{thunk} objekt uničen, lahko pri tem počistimo pomnilnik vseh objektov, ki si jih le-ta lasti.
    \item Pri pravilu \ref{eq:stg-casecon} trenuten objekt prevzame lastništvo nad vsemi argumenti konstruktorja. Zatem je lahko pomnilnik \textsc{con} objekta spro\-ščen, saj s tem vrednosti argumentov niso izbrisane pred uporabo. 
    \item Pri pravilu \ref{eq:stg-primop} najprej izračunamo rezultat primitivne operacije, nato pa lahko počistimo pomnilnik vseh objektov, ki so bili uporabljeni za izračun rezultata.
\end{itemize}

\subsubsection{Primer}

Program \ref{pr:sistem-lastnistva} prikazuje zakasnitev \var{t}, ki ustvari dva nova objekta na kopici in ju priredi spremenljivkama \var{a} in \var{b}. Pri prirejanju v spremenljivko \var{r} sta spremenljivki \var{a} in \var{b} v telesu funkcije \emph{prosti}, kar pomeni, da se lastništvo (in s tem odgovornost za čiščenje pomnilnika) prenese v objekt \textsc{fun}. Po premiku postaneta spremenljivki \var{a} in \var{b} neveljavni, kar pomeni, da se v telesu zakasnitve ne smeta več pojaviti. Telo najbolj ugnezdenega \texttt{let} izraza iz same zakasnitve \var{t} vrne tudi lastništvo nad spremenljivko \var{r}. To pomeni, da \textsc{thunk}, na katerega kaže spremenljivka \var{t}, ni več odgovoren za čiščenje pomnilnika nobene izmed spremenljivk, ki jih je definiral. Če program vsebuje kakršnokoli prirejanje, kjer se spremenljivka \var{t} pojavi na desni strani (angl. right-hand-side), potem objekt, v katerem se prirejanje nahaja, prevzame lastništvo nad objektom $\textsc{fun}(f \to f \: a \, b)$.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva \cmark}
t = THUNK(
    let a = THUNK(...)      in
    let b = THUNK(...)      in
    let r = FUN(f -> f a b) in  -- Premik
        r
)
\end{code-box}
\caption{Veljaven program v STG jeziku s sistemom lastništva}
\label{pr:sistem-lastnistva}
\end{primer}

Ena izmed optimizacij, ki jo lahko prevajalnik izvede, da s pomočjo analize prostih spremenljivk prepozna, katere izmed spremenljivk, definiranih v nekem objektu (z \texttt{let} izrazom), v nadaljevanju programa niso nikjer več uporabljene. Take definicije lahko prevajalnik iz programa odstrani ter s tem zmanjša količino objektov, ki se ustvarijo oziroma brišejo iz kopice.

\subsubsection{Prednosti in slabosti}

% Prednosti in slabosti jezika, ki vsebuje le premike
Prednost jezika STG, ki vsebuje le premike (tj. zgolj sistem lastništva) je zmožnost izvajanja avtomatičnega čiščenja pomnilnika brez uporabe tradicionalnega avtomatičnega čistilca pomnilnika. Vsak objekt na kopici dopolnimo s seznamom objektov, ki si jih le-ta lasti (tj. seznamom močnih kazalcev), operacijsko semantiko jezika pa dopolnimo tako, da se ob posodobitvah zakasnitev sprosti pomnilnik za objekte, ki so v seznamu. Kot smo že omenili, v jezik tako uvedemo sistem \emph{afinih} tipov, ki zagotavlja, da na vsak objekt kaže največ ena referenca, oziroma da je lahko vsaka spremenljivka uporabljena \emph{največ enkrat}. Če spremenljivka v nekem objektu ni nikjer uporabljena, potem lahko objekt, na katerega se le-ta sklicuje, izbrišemo s pomnilnika. Če je spremenljivka nekje uporabljena, potem se lastništvo prenese na nek drug objekt, ki postane odgovoren tudi za čiščenje pomnilnika. Z uvedbo sistema afinih tipov pa v STG vpeljemo tudi omejitve afinega sistema tipov. V takem jeziku lahko vsako spremenljivko (oziroma vsak objekt) uporabimo največ enkrat, kar pomeni, da ne moremo napisati programa \ref{pr:neveljavna-dvojna-uporaba}.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva \xmark}
main = THUNK(
    let a = ... in
    let b = CON(Pair a a) in -- (a, a)
        ...
)
\end{code-box}
\caption{Neveljavna dvojna uporaba spremenljivke pri STG jeziku s sistemom lastništva}
\label{pr:neveljavna-dvojna-uporaba}
\end{primer}

Ker STG jezik obravnava funkcije kot prvorazredne objekte, lahko spremenljivke hranijo reference na funkcije. To pa pomeni, da v afinem sistemu izgubimo možnost večkratne uporabe funkcij (tj. v takem jeziku ne smemo napisati izraza \texttt{f (f x)}, ki funkcijo \var{f} uporabi dvakrat), prav tako pa nam tak sistem tipov prepoveduje uporabo rekurzije. 

% Možne rešitve:
%   * slabša: uvedemo izraz clone
%   * boljša: podobno kot v Rustu, dodamo izposojo

\section{Globoko kloniranje objektov}

Glavna težava, ki se pojavi pri sistemu, ki vsebuje le princip lastništva, je nezmožnost deljenja (angl. sharing) objektov. Ena izmed možnih rešitev (implementirana tudi v delu \cite{marshall2024functional}) je vpeljava izraza \texttt{clone}, s pomočjo katerega je omogočeno eksplicitno globoko kloniranje (angl. deep clone) objektov na kopici. Pri tem se ustvari nova kopija objekta, vključno z vsemi njegovimi notranjimi strukturami in podatki. To pomeni, da se rekurzivno kopirajo tudi vsi ugnezdeni objekti in podatkovne strukture, ki jih vsebuje izvorni objekt. Rezultat je popolnoma neodvisna kopija originalnega objekta, kjer spremembe na kopiji ne vplivajo na original in obratno.

S pomočjo analize premikov lahko tako za vsak objekt zagotovimo, da na vsak objekt kaže natanko ena referenca, s pomočjo kloniranja pa lahko objekte podvajamo, ne da bi to predpostavko prekršili. Slabost takega pristopa je v tem, da je pri kloniranju velikih oziroma bolj kompleksnih objektov postopek kloniranja izredno časovno in prostorsko potraten~\cite{wadler1990linear, lafont1988linear}.

Do druge težave pride zaradi same lenosti izračuna.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik z globokim kloniranjem \xmark}
main = THUNK(
    let a = ... in
    let b = THUNK(clone a) in
        (f a) + b
)
\end{code-box}
\caption{Neučakani izračun pri globokem kloniranju}
\label{pr:globoko-kloniranje}
\end{primer}

Primer \ref{pr:globoko-kloniranje} prikazuje program, ki bi se v neučakanem jeziku izvedel brez težav. Ob prirejanju v spremenljivko \var{b} bi se namreč celoten objekt na kopici, na katerega kaže spremenljivka \var{a}, kopiral, kar pomeni, da sta objekta, na katera kažeta spremenljivki \var{a} in \var{b}, povsem disjunktna (tj. njuna grafa v pomnilniku si ne delita nobenega vozlišča). Funkcija \var{f} prevzame lastništvo nad \var{a} in s tem tudi odgovornost za čiščenje pomnilnika. Če se v izrazu $(f \; a) \, + \, b$ torej najprej izvede aplikacija $f \; a$, potem se pomnilnik spremenljivke \var{a} tudi ustrezno počisti. Toda, spremenljivka \var{b} kaže na zakasnitev, ki pa še ni bila izračunana, ta pa vsebuje referenco na sedaj neobstoječo spremenljivko \var{a}, kar pomeni, da pride pri izvajanju programa do napake.

Če bi želeli, da se program pravilno izračuna, bi torej morali v STG jezik ponovno uvesti neučakanost pri računanju, na podoben način kot pri \texttt{let!} izrazu v Wadlerjevem jeziku s sistemom stanovitnih linearnih tipov~\cite{wadler1990linear}. Pri tem se desna stran prirejanja izračuna \emph{v celoti}, preden se izvede telo izraza, kar Wadler imenuje za hiperstriktni izračun (angl. hyperstrict evaluation). Ker je leni izračun osnova STG jezika, ta pristop ne pride v poštev.

\section{Izposoja}

% Druga rešitev, s pomočjo katere lahko v programski jezik s sistemom lastništva ponovno uvedemo deljenje izrazov, temelji na Rustovem modelu izposoje. Če lahko pri lastništvu objektov vsako spremenljivko uporabimo le enkrat, nam izposoja omogoča, da je lahko spremenljivka nespremenljivo izposojena (in s tem uporabljena) večkrat, ali pa spremenljivo izposojena enkrat.

% Izposoja - splošno in uporaba v Rust in Blang
Druga rešitev za ponovno uvedbo deljenja izrazov v programskem jeziku s sistemom lastništva temelji na konceptu izposoje, kot ga poznamo iz programskega jezika Rust. Implementiran sistem lastništva zahteva, da je vsaka spremenljivka uporabljena največ enkrat. Koncept izposoje omogoča, da je spremenljivka bodisi nespremenljivo izposojena (in s tem uporabljena) večkrat bodisi je spremenljivo izposojena le enkrat. Programski jezik Rust~\cite{klabnik2023rust} uvede koncept življenjskih dob, s pomočjo katerih v fazi analize izposoj zagotovi, da je življenjska doba objekta daljša od življenjske dobe izposoje. Len funkcijski jezik Blang~\cite{turk2022len} na podlagi Rustovega modela lastništva implementira tako analizo premikov kot tudi analizo izposoj. Jezik (podobno kot npr. Ocaml in Scala) podpira mutacijo in na podlagi principa izključitve v Rustu tudi spremenljive in nespremenljive izposoje. Podobno kot Rust tudi Blang definira pojem življenjskih dob, ki jih zmore v določenih primerih prevajalnik izračunati sam, v drugih primerih pa zahteva, da programer življenjske dobe in tipe navede eksplicitno.

\subsubsection{Mutacija v STG jeziku}
% STG jezik - nimamo spremenljivih izposoj
Pri STG jeziku lahko nove spremenljivke definiramo s pomočjo \texttt{let} izraza, ki na kopici ustvari nov objekt, v spremenljivko pa se shrani pomnilniški naslov le-tega. Jezik STG ne vsebuje nobenega konstrukta, s pomočjo katerega bi obstoječi spremenljivki priredili drugo vrednost. Pri definiciji spremenljivke z enakim imenom se prejšnja vrednost ne prepiše, temveč \emph{zasenči} (angl. shadow). Na kopici se ustvari nov objekt, pri čemer se vse nadaljnje uporabe spremenljivke sklicujejo na novonastali objekt, pri vseh objektih, ki so nastali prej, pa spremenljivka vsebuje naslov prejšnjega objekta. Jezik STG torej ne omogoča neposredne mutacije vrednosti obstoječih spremenljivk.

Jezik STG učinkovito implementacijo lenega izračuna doseže s pomočjo principa prenosa po potrebi (angl. call by need), pri katerem se vrednost zakasnitve izračuna prvič, ko je potrebovana, nato pa se v pomnilniku objekt zamenja s preusmeritvijo na rezultat. Ob vsaki nadaljnji uporabi se vrednost enostavno prebere s pomnilnika. Torej so edini vir mutacij v STG jeziku posodobitve zakasnitev (angl. thunk updates). Rust podpira spremenljive in nespremenljive izposoje, ker pa v STG jeziku ni mutacije, se bomo v našem delu ukvarjali le z nespremenljivimi izposojami.

% Edini vir mutacije v STG jeziku so posodobitve zakasnitev (angl. thunk updates), pri katerih se objekt v pomnilniku prepiše s preusmeritvijo (objektom \textsc{indirection}) na rezultat izračuna. \komentar{Kako delujejo posodobitve?}

% Tako so pri STG jeziku edini vir mutacij posodobitve zakasnitev (angl. thunk updates), pri katerih se objekt v pomnilniku prepiše s preusmeritvijo na rezultat izračuna. Ker spremenljivke vsebujejo kazalce na objekte na kopici, to omogoča učinkovito deljenje in ponovno uporabo podatkov brez nepotrebnega kopiranja. Rust podpira spremenljive in nespremenljive izposoje, ker pa v STG jeziku ni mutacije, se bomo v našem delu ukvarjali le z nespremenljivimi izposojami.

% Kaj torej ponazarjajo naše spremenljive in nespremenljive izposoje?
V poglavju \ref{sec:analiza-premikov} smo definirali analizo premikov, pri kateri pride pri uporabi spremenljivke do premika in s tem do prenosa odgovornosti za čiščenje pomnilnika premaknjenega objekta. Pri nespremenljivi izposoji, ki jo bomo označevali z \texttt{\&x}, je omogočen dostop do spremenljivke \var{x}, pri tem pa se \emph{ne} prenese odgovornost za čiščenje pomnilnika. Podobno kot pri premikih bomo tudi pri izposojah predpostavljali, da pride do izposoje ob prirejanju in ne ob dejanski uporabi spremenljivke. Naslednji primer prikazuje program, ki najprej na kopici ustvari objekt in ga priredi spremenljivki \var{a}, nato pa se na kopici ustvarita še dve zakasnitvi, ki si izposodita spremenljivko \var{a}.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje}
main = THUNK(
    let a = ... in
    let b = THUNK(... &a ...) in -- Izposoja
    let c = THUNK(... &a ...) in -- Izposoja
        ...
)
\end{code-box}
\caption{Več hkratnih izposoj spremenljivke}
\label{pr:}
\end{primer}


% Premik - odgovornost za čiščenje pomnilnika
% Izposoja - zavoljo deljenja vrednosti (učinkovita implementacija)
Po pravilih lastništva je zakasnitev \var{main} lastnik spremenljivk \var{a}, \var{b} in \var{c}, kar pomeni, da lahko ob posodobitvi počisti tudi pomnilnik spremenljivk \var{a}, \var{b} in \var{c}. Objekta, na katera kažeta spremenljivki \var{b} in \var{c}, si izposojata spremenljivko \var{a}. Ker je spremenljivka \var{a} prosta znotraj zakasnitev, se pojavi v okolju znotraj ovojnice obeh zakasnitev, ker pa je spremenljivka izposojena in ne premaknjena, se \emph{ne} pojavi v seznamu močnih kazalcev zakasnitev in tako njen pomnilnik ni počiščen ob posodobitvi zakasnitev.

\subsubsection{Uvedba izposoje v STG}

% atom ::= ... | &x
Za uvedbo izposoje v jezik STG je najprej potrebno razširiti semantiko jezika z dodajanjem operacije za izposojo:

\begin{align*}
	a, v \quad \coloneq& \quad \dots \enspace \vert \enspace \& x & \text{atomarni izrazi}
\end{align*}

% Popravek analize premikov
V analizo premikov dodamo pravilo
\begin{equation}
\infers[borrow]{
    x \in \Delta
}{
    \langle \Delta, \, \& x \rangle
}{
	\Delta
}
\label{eq:borrow}
\end{equation}
ki deluje na podoben način kot pravilo \ref{eq:var}, le da pri tem iz konteksta $\Delta$ ne odstrani spremenljivke, saj pri izposoji vrednost ni premaknjena.

Primer \ref{pr:izposoja-premaknjene-spremenljivke} prikazuje program, ki najprej ustvari spremenljivko \var{a}, nato pa ustvari spremenljivko \var{b} in pri tem prenese lastništvo v objekt \object{thunk}, na katerega kaže spremenljivka \var{b}. Pri tem spremenljivka \var{a} ni več veljavna in je zato pri analizi premikov odstranjena iz konteksta $\Delta$. Pri analizi objekta, na katerega kaže \var{c}, pride tako do napake, saj se kontekst $\Delta$ in izraz \texttt{\&a} ne ujemata s pravilom \ref{eq:borrow} (ker velja $a \notin \Delta$).

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje \xmark}
main = THUNK(
    let a = ... in
    let b = THUNK(... a ...) in
    -- Neveljavna izposoja, spremenljivka a je bila že premaknjena
    let c = THUNK(... &a ...) in 
        ...
)
\end{code-box}
\caption{Izposoja premaknjene spremenljivke}
\label{pr:izposoja-premaknjene-spremenljivke}
\end{primer}

Primer \ref{pr:premik-izposojene-spremenljivke} prikazuje program, ki bi uspešno prestal \emph{analizo premikov} (ne pa tudi analize izposoj). Objekt \var{b} si namreč spremenljivko \var{a} le izposodi in je ne odstrani iz konteksta $\Delta$. Objekt \var{c} spremenljivko \var{a} dejansko premakne in jo odstrani iz konteksta, pri čemer ta postane neveljavna v telesu \texttt{let} izraza.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje \cmark}
main = THUNK(
    let a = ... in
    let b = THUNK(... &a ...) in
    -- Neveljaven premik, spremenljivka a je že bila izposojena
    let c = THUNK(... a ...) in
        ...
)
\end{code-box}
\caption{Premik že izposojene spremenljivke}
\label{pr:premik-izposojene-spremenljivke}
\end{primer}

Tak program bi v Rustu javil napako, saj spremenljivka ne sme biti premaknjena, dokler je izposojena (tj. dokler nanjo obstaja živa referenca). Za prepoznavanje tovrstnih napak v Rustu poskrbi analiza izposoj (angl. borrow check).

\subsubsection{Izposoje v lenem STG jeziku}

% Prednost lenega izračuna je v dejstvu, da se vrednosti izračunajo le enkrat ali pa sploh ne. Pri klicu funkcije, ki argumenta ne uporabi, se ta niti ne izračuna. 

% Pri prejšnjem primeru funkcija \var{success} pri sestavljanju rezultata ni uporabila vrednosti svojega argumenta (tj. izposoje spremenljivke \var{item}), zato je bil program tudi veljaven. V večini primerov pa bi seveda radi, da funkcije izposojene argumente tudi uporabijo pri izračunu rezultata. Primer take funkcije bi bila npr. funkcija \var{add}, ki kot vhod sprejme dve izposojeni vrednosti, ter na podlagi njunih vrednosti sestavi nov objekt \object{con} na kopici, ki vsebuje njuno vsoto. Ker sta oba vhoda izposojeni vrednosti, taki funkciji ni potrebno čistiti pomnilnika. Prav tako pa taka funkcija ustvari le en nov objekt na kopici in lastništvo le-tega preda klicatelju funkcije.

Program \ref{pr:funkcija-add} prikazuje funkcijo \var{add}, ki kot vhod sprejme dve referenci na celi števili ter na podlagi njunih vrednosti sestavi nov objekt \object{con} na kopici, ki vsebuje njuno vsoto. Pri tem funkcija uokvirjena argumenta \var{x} in \var{y} najprej razpakira in izračuna njuno vsoto s pomočjo primitivne operacije \texttt{+\#}. Ker sta oba vhoda izposojeni vrednosti, taka funkcija ni odgovorna za čiščenje pomnilnika argumentov, prav tako pa funkcija ni odgovorna za čiščenje pomnilnika spremenljivke \var{result}, saj je ta premaknjena iz objekta. Glede na implementacijo funkcije \var{add} lahko sklepamo, da bo rezultat izračuna \texttt{add \&x \&y} vrednost, ki ne vsebuje več kazalcev na spremenljivki \var{x} in \var{y}, kar pomeni, da se pri uporabi funkcije \texttt{add \&x \&y} izposoji spremenljivk \var{x} in \var{y} zaključita.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje \cmark}
-- add :: &'A Integer -> &'A Integer -> Integer
add = FUN(x y -> 
    case x of {
        Integer i -> case y of {
            Integer j -> case +# i j of {
                value -> let result = CON(Integer value) in result
            }
        }
    }
)
\end{code-box}
\caption{Vsota celih števil}
\label{pr:funkcija-add}
\end{primer}

Primer \ref{pr:izposoja-neveljaven} prikazuje program, ki bi se v originalni različici STG jezika izvedel brez težav, v naši različici z modelom lastništva in izposoje pa ne. Program na kopici najprej ustvari tri objekte, ki pa se še \emph{ne} izračunajo. Objekt \var{sum} v svoji ovojnici vsebuje kazalec na spremenljivko \var{x}, objekt \var{result} pa kazalec na \var{sum}. Ker lastništva spremenljivke \var{x} ne prenesemo iz zakasnitve \var{main}, je po pravilih našega modela premikov in izposoj ta tudi odgovorna za čiščenje pomnilnika le-te. Ker pa objekt, na katerega kaže spremenljivka \var{sum} še ni do konca izračunan, še vedno vsebuje kazalec na spremenljivko \var{x}. Če torej iz funkcije premaknemo objekt \var{result}, v program uvedemo viseč kazalec, saj je pomnilnik spremenljivke \var{x} po posodobitvi sproščen, pri zakasnjenem izračunu vrednosti objekta \var{result} pa pride do dostopa do neveljavnega naslova in posledično do sesutja programa.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje \xmark}
main = THUNK(
    let x = CON(Integer 8) in
    let sum = THUNK(add &x &x) in
    let result = CON(Just sum) in
        result
)
\end{code-box}
\caption{Neveljaven program z izposojami}
\label{pr:izposoja-neveljaven}
\end{primer}

V primeru \ref{pr:izposoja-veljaven} pred sestavljanjem objekta \object{con} z rezultatom s \texttt{case} izrazom do konca izračunamo vrednost izraza \var{sum}. Po pravilih operacijske semantike iz poglavja \ref{sec:stg-operacijska-semantika}, se izraz v \texttt{case} izrazu (angl. scrutinee) izračuna do svoje šibke normalne oblike glave (angl. weak head normal form)~\cite{jones1992implementing}. Objekti tipa \object{thunk} so v svoji šibki normalni obliki glave kadar se do konca izračunajo in se izvede posodobitev, pri čemer se v pomnilniku ustvari objekt \object{indirection} na izračunano vrednost. Glede na implementacijo funkcije \var{add} v primeru \ref{pr:funkcija-add} se ob izračunu zakasnitve \var{sum} izposoji spremenljivke \var{x} zaključita, spremenljivka \var{value} pa prevzame lastništvo nad objektom z vsoto. V tem primeru se izposoji torej zaključita, preden se zakasnitev \var{main} do konca izračuna, kar pomeni, da je tak program veljaven in je pomnilnik vseh objektov uspešno počiščen.

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje \cmark}
main = THUNK(
    let x = CON(Integer 8) in
    let sum = THUNK(add &x &x) in
    case sum of {
        value -> let result = CON(Just value) in
                     result
    }
)
\end{code-box}
\caption{Veljaven program z izposojami}
\label{pr:izposoja-veljaven}
\end{primer}

\begin{primer}[ht]
\centering
\begin{code-box}{haskell}{STG jezik s sistemom lastništva in izposoje \cmark}
main = THUNK(
    let x = CON(Integer 8) in
    let sum1 = THUNK(add &x &x) in
    let sum2 = THUNK(add &x &x) in
    let pair = CON(Pair sum1 sum2) in
    case pair of {
        Pair first second ->                -- P1
            case second of {
                secondValue ->              -- P2
                    case first of {
                        firstValue -> ...   -- P3
                    }
            }
    }
)
\end{code-box}
\caption{Ekspliciten vrstni red računanja v lenem STG jeziku}
\label{pr:ekspliciten-vrstni-red}
\end{primer}

Primer \ref{pr:ekspliciten-vrstni-red} prikazuje program, ki ustvari par \mintinline{haskell}{(add &x &x, add &x &x)} s štirimi izposojami. Da zagotovimo ustrezno čiščenje pomnilnika, je potrebno poskrbeti, da se do konca izračunata obe zakasnitvi \var{sum1} in \var{sum2} (kadar se namreč izračuna vrednost zakasnitve \mintinline{haskell}{(add &x &x)}, se obe izposoji spremenljivke \var{x} zaključita). Pri izračunu spremenljivke \var{pair} s \texttt{case} izrazom (oznaka \texttt{P1}), se levi in desni izraz še ne izračunata, ker so konstruktorji \object{con} že v šibki normalni obliki glave. To pomeni, da vsebujeta spremenljivki \var{first} in \var{second} kazalca na neizračunani zakasnitvi na kopici. Drugi \texttt{case} izraz (oznaka \texttt{P2}) eksplicitno sproži izračun desnega elementa para, pri čemer se do konca izračuna zakasnitev \object{thunk} in s tem zaključita izposoji spremenljivke \var{x}. Pri tem pa še vedno obstajata dve izposoji spremenljivke \var{x} znotraj zakasnitve \var{sum1}, ki pa še nista bili zaključeni. Zadnji \texttt{case} izraz (oznaka \texttt{P3}) do konca izračuna še zadnjo zakasnitev \var{sum1} in s tem zaključi še zadnji izposoji spremenljivke \var{x}. Ker so bile vse izposoje zaključene pred izračunom zakasnitve, v kateri je bila izposojena spremenljivka ustvarjena, je tak program veljaven. Na tem mestu je pomembno omeniti, da je bila za zaključevanje izposoj potrebna uporaba \texttt{case} stavka, s katero pa smo v program uvedli tudi vrstni red računanja: najprej se namreč izračuna desni izraz para, nato pa še levi.

Glavna težava sistema izposoj je torej v tem, da je potrebno zagotoviti, da se izposoja zaključi, preden se do konca izračuna objekt, ki je ustvaril spremenljivko, ki je izposojena. Sam izračun vrednosti lahko sprožimo le s pomočjo \texttt{case} izraza, ki najprej izračuna podizraz v njegovo šibko normalno obliko glave, nato pa izvede eno izmed alternativ. Da pa zagotovimo, da se izposoja zaključi med prevajanjem programa, je potrebno prevajalniku podati več informacij. Ena izmed možnih rešitev je uvedba informacij o izračunanosti izrazov. Ta bi od programerja zahtevala, da za objekte, ustvarjene z \texttt{let} izrazom in argumente funkcij eksplicitno navede podatek o tem, ali je bil izraz že izračunan do svoje šibke normalne oblike glave. Treba je tudi navesti, ali funkcija kakšnega izmed argumentov izračuna. Funkcija $\var{id} = \object{FUN}(x \to x)$ namreč sprejme izposojo in je ne zaključi, medtem ko funkcija \var{add} iz primera \ref{pr:funkcija-add} sprejme dve izposoji in ju tudi zaključi.

Ta rešitev pa nas v določenih primerih (npr. primer \ref{pr:ekspliciten-vrstni-red}) vrača nazaj na to, da je sam vrstni red računanja izrazov pomemben. Programer mora namreč v \emph{lenem} jeziku razmišljati o tem, kdaj se izrazi izračunajo, prav tako pa mora eksplicitno zagotoviti, da so vsi izrazi do konca izračunani, pri čemer si lahko pomaga s \texttt{case} izrazom, ki v jezik uvede vrstni red izvajanja izrazov. Uvedba izposoj v len programski jezik torej od programerja zahteva določanje eksplicitnega vrstnega reda izvajanja operacij, kar pa je povsem v nasprotju z nestrogimi programskimi jeziki in lenim izračunom. Iz te zagate si je Philip Wadler pomagal z uvedbo dodatnega stavka \texttt{let!}, s katerim je dodal strogi izračun v sicer len programski jezik~\cite{wadler1990linear}.

% Zaključek:
% Sam sistem lastništva - problem, ker dodamo sezname, katerih dolžina se lahko spreminja. Dodajamo in odstranjujemo lahko namreč močne kazalce, kar pomeni, da morajo biti implementirani s pomočjo povezanega seznama ali nekega drevesa (=> linearna časovna zahtevnost + poskrbeti je potrebno za duplikate).
% Še en problem je hramba teh seznamov / dreves na kopici. Objekti so že tako različnih velikost (ampak najmanj 2 zaradi preusmeritve), dodajanje in odstranjevanje močnih kazalcev pa lahko prekorači velikost objekta => sezname / drevesa je potrebno hraniti drugje na kopici (prostorsko potratno, cache miss problemi)
% Če pogledamo še globoko kloniranje - zelo časovno in prostorsko neučinkovito.
% Pri sami implementaciji izposoj pride pa še do dodatne težave - izposoja se more nujno zaključiti preden se konča izvajati objekt, ki jo je ustvaril. Ta namreč pomnilnik spremenljivke sprosti, če pa je izposoja še vedno aktivna pride pri tem do visečih kazalcev. Da pa zagotovimo, da se izposoja zaključi preden se objekt izbriše iz pomnilnika, ga moramo eksplicitno 