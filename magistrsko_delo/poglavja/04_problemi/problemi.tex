\chapter[Življenjske dobe in leni izračun]{Težave pri izračunu življenjskih dob pri lenem izračunu}

Za potrebe naše magistrske naloge smo pripravili simulator abstraktnega STG stroja\footnote{Dostopen na naslovu \url{https://github.com/nikibizjak/magistrsko-delo}.}, ki zna razčleniti kodo napisano v STG jeziku in jo izvesti. Namen našega dela je bil v simulator dodati analizo premikov in izposoj, kot jo poznamo v Rustu. Za osnovo smo vzeli len programski jezik Blang~\cite{turk2022len}, ki naj bi za upravljanje s pomnilnikom že uporabljal model lastništva in izposoje.

% TODO: Manjka še kaj vsebine

\komentar{Mogoče bi bilo smiselno citirati še Andraževo delo, če ga uspe dokončati pred mano}

\section{Implementiran prevajalnik}
Slika \ref{fig:shema-implementacije} prikazuje zamišljeno strukturo našega prevajalnika. Z odebeljeno pisavo so označene faze, ki smo jih v naš prevajalnik uspešno implementirali. Implementacija vhodni program prebere iz datoteke, ter v fazi razčlenjevanja (angl. parsing) sestavi abstraktno sintaksno drevo. Nad drevesom se izvedeta dve vrsti semantične analize:

\begin{itemize}
    \itemsep 0em
    \item Pri razreševanju imen prevajalnik preveri, ali so bile vse spremenljivke definirane preden so bile uporabljene, s čemer se zagotovi, da pri izvajanju ne bo prišlo do napak zaradi dostopa do spremenljivk, ki ne obstajajo.
    \item Pri analizi mestnosti (angl. arity analysis) se pri aplikacijah funkcij $f^k \; a_1 \dots a_n$ za funkcije izračuna njihovo mestnost $k$. Pri sestavljanju abstraktnega sintaksnega drevesa prevajalnik namreč vse aplikacije označi z neznano mestnostjo $f^{\bullet} \; a_1 \dots a_n$. Za funkcije, ki so bile uvedene s pomočjo konstruktorja \textsc{fun}, lahko prevajalnik mestnost določi na podlagi števila parametrov. Za tiste aplikacije funkcij, ki jim mestnosti ni mogoče določiti (npr. funkciji $f$ v izrazu \texttt{apply = FUN(f x -> f x)}), se uporabi neznana mestnost $\bullet$, za izvajanje pa poskrbijo  ustrezna pravila (\textsc{exact}, \textsc{tcall}, $\dots$) operacijske semantike.
\end{itemize}

Po semantični analizi se začne izvajanje STG programa s pomočjo abstraktnega STG stroja, ki implementira pravila operacijske semantike opisana v poglavju \ref{sec:operacijska-semantika}. Implementacija sestoji iz izraza, ki ga trenutno računamo, sklada, ki hrani nadaljevanja in kopice, na kateri so shranjeni \textit{objekti}, ki jih STG stroj obdeluje (tj. objekti \textsc{thunk}, \textsc{fun}, \textsc{con}, \textsc{pap}, \textsc{blackhole}). Vsak objekt na kopici vsebuje še okolje (angl. environment), ki imena spremenljivk slika v naslove povezanih objektov na kopici. Prevajalnik zna okolja optimizirati tako, da v njih hrani le nujno potrebne spremenljivke, tj. spremenljivke, ki so v telesu objekta proste (angl. free variables).

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{
			every node/.append style={text width=1.4cm,execute at begin node=\setlength{\baselineskip}{1em},font=\footnotesize},
			block/.style={draw,rectangle,text width=2cm,align=center,minimum height=1cm,minimum width=2cm},
		}
		
		\node[block] (parser) {\textbf{Razčlen\-jevanje}};
		
		\node[coordinate, left=0.5cm of parser.west] (levo-od-parser) {};

        \node[coordinate, right=2.2cm of parser] (center) {};
		
		% \node[block,right=1cm of parser] (borrow-checker) {Analiza izposoj};
        \node[block,below=0.25cm of center] (borrow-checker) {\textbf{Analiza premikov}};
        \node[block, above=0.5cm of borrow-checker] (arity-analysis) {\textbf{Analiza mestnosti}};
		\node[block, above=0.5cm of arity-analysis] (name-resolution) {\textbf{Raz\-re\-še\-van\-je imen}};
		\node[block, below=0.5cm of borrow-checker] (move-checker) {Analiza izposoj};
		\node[block, right=2.2cm of center] (interpreter) {\textbf{Abstraktni stroj STG'}};
		
		\node[coordinate, right=0.5cm of interpreter.east] (desno-od-interpreter) {};
		
		% Input arrow
		\draw[->] (levo-od-parser) -- (parser) node[above, pos=-0.25,align=center] {\scriptsize tok\\znakov};
		
		% Output arrow
		\draw[->] (interpreter) -- (desno-od-interpreter) node[above,pos=1.25,align=center] {\scriptsize rezultat};
		
		% Parser -> name resolution arrow
		\node[coordinate, right=0.3cm of parser.east] (desno-od-parser) {};
		\node[coordinate] at (desno-od-parser |- name-resolution) (levo-od-name-resolution) {};	
		\draw[->] (parser) -- (desno-od-parser) -- node[align=center,sloped,anchor=center,above,pos=0.75] {\scriptsize STG} (levo-od-name-resolution) -- (name-resolution);
		
		% Move checker -> abstract STG machine arrow
		\node[coordinate, left=0.3 of interpreter.west] (levo-od-interpreter) {};
		\node[coordinate] at (move-checker -| levo-od-interpreter) (desno-od-move-checker) {};
		\draw[->] (move-checker.east) -- (desno-od-move-checker) -- node[align=center,sloped,anchor=center,below,pos=0.25] {\scriptsize STG'} (levo-od-interpreter) -- (interpreter);
		
		% 
		\draw[->] (name-resolution) -- node[pos=0.5,right] {\scriptsize STG} (arity-analysis);
        \draw[->] (arity-analysis) -- node[pos=0.5,right] {\scriptsize STG} (borrow-checker);
		\draw[->] (borrow-checker) -- node[pos=0.5,right] {\scriptsize STG'} (move-checker);
		
		% Oznake za semantično analizo
		\node[coordinate, above=0.4 of name-resolution.north] (top) {};
		\node[coordinate, below=0.4 of move-checker.south] (bottom) {};
		
		\node[coordinate, left=0.5 of borrow-checker.west] (semanticna-analiza-levo) {};
		\node[coordinate, right=0.5 of borrow-checker.east] (semanticna-analiza-desno) {};
		
		\node[coordinate] at (semanticna-analiza-levo |- top) (semanticna-analiza-levo-zgoraj) {};
		\node[coordinate] at (semanticna-analiza-levo |- bottom) (semanticna-analiza-levo-spodaj) {};
		
		\node[coordinate] at (semanticna-analiza-desno |- top) (semanticna-analiza-desno-zgoraj) {};
		\node[coordinate] at (semanticna-analiza-desno |- bottom) (semanticna-analiza-desno-spodaj) {};
		
		\draw[-,dashed] (semanticna-analiza-levo-zgoraj) -- (semanticna-analiza-levo-spodaj) -- (semanticna-analiza-desno-spodaj) -- (semanticna-analiza-desno-zgoraj) -- (semanticna-analiza-levo-zgoraj);
		
		\path (semanticna-analiza-levo-zgoraj) -- node[above=0.1,align=center,text width=3cm] {Semantična analiza} (semanticna-analiza-desno-zgoraj);
		
	\end{tikzpicture}
	\caption{Predvidena struktura implementiranega prevajalnika}
	\label{fig:shema-implementacije}
\end{figure}

\section{Vrstni red izračuna izrazov}

\subsection{Neučakanost jezika Rust}

Programski jezik Rust implementira strogo semantiko, kar pomeni, da se pri klicu funkcije najprej izračunajo vrednosti argumentov, ki so nato ob klicu posredovane v telo funkcije. Prav tako se zaradi neučakanosti pri prirejanju v spremenljivko (tj. izrazu \mintinline{rust}{let lhs = rhs;}), najprej do konca izračuna vrednost desnega dela prirejanja \textit{rhs}. V splošnem velja, da če se stavek $s_1$ v programu pojavi leksikalno pred stavkom $s_2$, potem se bo stavek $s_1$ zagotovo izvedel pred $s_2$~\komentar{\cite{}}.

V tem poglavju bomo predpostavljali, da se dosegi spremenljivk računajo glede na leksikalen doseg. Kot smo že omenili v poglavju \ref{sec:rustov-model-lastnistva}, zna Rust življenjske dobe računati neleksikalno. To pomeni, da se pri analizi živ\-ljenj\-skih dob izvede še analiza živosti spremenljivk (angl. liveness analysis) s pomočjo katere se lahko življenjske dobe določijo bolj natančno. Posledično imajo lahko spremenljivke krajšo življenjsko dobo kot funkcija, ki jih je ustvarila. V tem poglavju bomo predpostavljali, da je spremenljivka živa od njene uvedbe, do konca bloka v katerem je bila deklarirana, oziroma do prvega (in tudi edinega) premika spremenljivke.

Spodnji primer prikazuje program v Rustu, ki vsebuje tri zaporedne klice funkcij. Zaradi neučakanosti jezika se bodo stavki zagotovo izvajali glede na vrstni red, v katerem so zapisani. Tako se bo klic funkcije \texttt{mul} zagotovo izvedel pred klicem \texttt{div}, ta pa se bo zagotovo izvedla pred klicem \texttt{add}.

\begin{rust-success}
fn izracunaj() -> i32 {
    let a = mul(6, 2);
    let b = div(8, 2);
    let r = add(b, a);
    return r;
}
\end{rust-success}

% Življenjske dobe.


% Če predpostavimo, da se v Rustu življenjske dobe računajo leksikalno.
Ker je vrstni red operacij natanko določen, je zelo preprosto izračunati tudi življenjske dobe. V zgornjem primeru ima spremenljivka $a$ zagotovo daljšo življenjsko spremenljivko $b$, saj je bila deklarirana pred uvedbo spremenljivke $b$. Ker bi se spremenljivka $b$ lahko sklicevala na spremenljivko $a$, je potrebno zagotoviti, da spremenljivka $a$ živi vsaj toliko časa kot $b$, kar pomeni da je življenjska doba spremenljivke $a$ večja od $b$.

% Opis kako bi se to izvedlo v lenem izračunu
\subsection{Lenost jezika STG}

Zgornji program bi v STG jeziku napisali na zelo podoben način. Pri deklaraciji spremenljivke z \texttt{let} izrazom, se na kopici ustvari nov objekt. Ta je lahko konstruktor algebraičnega tipa \textsc{con}, funkcija \textsc{fun} ali še neizračunan izraz \textsc{thunk}. Objekta z delno aplikacijo \textsc{pap} in črna luknja \textsc{blackhole} se neposredno v programu nikoli ne moreta pojaviti, temveč ju lahko na kopici ustvari le prevajalnik oziroma izvajalno okolje. V programu še upoštevamo, da vse tri funkcije \texttt{mul}, \texttt{div} in \texttt{add} kot vhodna argumenta sprejmejo uokvirjeni (angl. boxed) vrednosti. Funkcije najprej izračunajo levo vrednost in jo odpakirajo (angl. unbox), nato pa enako storijo še za desno vrednost. Pri klicu funkcij \texttt{mul}, \texttt{div} in \texttt{add} je torej potrebno vrednosti najprej uokviriti (angl. box). V našem programu so \texttt{six}, \texttt{two} in \texttt{eight} globalne spremenljivke, ki vsebujejo uokvirjena cela števila, tj. spremenljivka \texttt{two} hrani npr. kazalec na objekt \texttt{CON(Integer 2)} na kopici.

\begin{code-box}{haskell}{STG jezik \cmark}
izracunaj = THUNK(
    let a = THUNK(mul six two) in
    let b = THUNK(div eight two) in
    let r = THUNK(add b a) in
        r
)
\end{code-box}

Pri zgornjem programu se na kopici najprej ustvarijo trije novi objekti z neizračunanimi izrazi \textsc{thunk}. Po definiciji jezika STG, se objekti ustvarijo v takem zaporedju, kot se v programu pojavijo, a se tukaj, za razliko od Rusta, pri prirejanju še ne izračunajo. Izračun se sproži šele ko se začne evalvacija izraza $r$ v telesu \texttt{let} izraza. Pri tem se začne izračun zakasnitve \texttt{THUNK(add b a)}, ki glede na definicijo funkcije \texttt{add} najprej evalvira levi, nato pa še desni izraz. Pri neučakanem računu se vrednosti spremenljivk izračunajo v vrstnem redu, kot so bile definirane, tj. $a$, $b$, $r$, medtem ko se pri lenem izračunu vrednosti izračunajo v vrstnem redu $b$, $a$, $r$. Pri jezikih z lenim izračunom, je vrstni red računanja odvisen od samih implementacij funkcij, kar oteži semantične analize v prevajalniku.

Kljub temu, da je program na pogled dokaj preprost, za izračun v našem simulatorju potrebujemo 61 korakov redukcije.

\section{Analiza premikov v STG jeziku}
\label{sec:analiza-premikov}
% \section{Uvedba lastništva v STG}

V poglavju \ref{sec:stg-jezik} smo videli, da jezik STG sestoji iz le peščice operacij: atomarne operacije, aplikacij funkcij oziroma primitivnih operacij, izraza \texttt{let}, ki na kopici ustvari nove objekte in izraza \texttt{case}, s katerim se sproži izračun zakasnitve (angl. forcing a thunk) in glede na rezultat izvede eno izmed možnih alternativ.

Pri izrazu \texttt{let} se najprej na kopici ustvari nov objekt, nato pa se izvede še telo izraza. Spodnji primer prikazuje dva zaporedna (oziroma bolj natančno, vgnezdena) \texttt{let} izraza, ki ustvarita spremenljivki $a$ in $b$. S pravili izračuna zakasnitev je zagotovljeno, da se bo objekt, na katerega kaže spremenljivka $a$, na kopici ustvaril \emph{pred} objektom, na katerega kaže spremenljivka $b$.

\begin{code-box}{haskell}{STG jezik \cmark}
main = THUNK(
    let a = THUNK(...) in -- let1
    let b = THUNK(...) in -- let2
        -- body2
)
\end{code-box}

Toda, ker je jezik len, je vrstni red računanja vrednosti objektov $a$ in $b$ odvisen od samega izraza v telesu \texttt{body2}. Lahko se zgodi, da sta spremenljivki uporabljeni kot argumenta pri klicu funkcije, ki ju izračuna v poljubnem vrstnem redu (oziroma ju sploh ne), zaradi česar je pri prevajanju skoraj nemogoče predvideti v katerem vrstnem redu se bodo objekti evalvirali.

\subsection{Formalna definicija analize premikov}
% Ideja: Kaj če lastništvo prenašamo kadar se objekt ustvari?
Ta lastnost \texttt{let} izraza, nam da idejo za implementacijo analize premikov (angl. move check), ki zna zagotoviti, da na vsak objekt na kopici kaže natanko ena referenca. Pri tem upoštevamo, da se las\-tni\-štvo prenese ob \textit{ustvarjanju} objekta na kopici. Tako analizo lahko izvedemo leksikalno nad abstraktnim sintaksnim drevesom v času prevajanja.

Enačba \ref{eq:analiza-premikov-oblika-pravil} prikazuje obliko pravil analize premikov. Kot lahko vidimo, ta kot vhod sprejme izraz $expr$ in množico trenutno veljavnih spremenljivk $\Delta$. Množica vsebuje vse spremenljivke, do katerih lahko v danem trenutku dostopamo, tj. spremenljivk, ki še niso bile premaknjene. Rezultat analize je nova množica spremenljivk, ki so veljavne po izvajanju izraza $expr$. Če se izraz $expr$ ne ujema z nobenim izmed pravil, prevajalnik vrne napako.

\begin{equation}
    \Delta; \, expr \leadsto \Delta'
    \label{eq:analiza-premikov-oblika-pravil}
\end{equation}

Enačbi \ref{eq:int} in \ref{eq:var} podajata pravili za analizo premikov za atomarne operacije. Pravilo \ref{eq:int} ne spreminja konteksta, saj izraz ne uporabi nobene spremenljivke in tako ne prenese lastništva. Pravilo \ref{eq:var} obravnava primer uporabe spremenljivke, pri katerem pride do prenosa lastništva. Spremenljivka $x$ v nadaljevanju ni več veljavna, zato je odstranjena s konteksta $\Delta$. S pomočjo pogoja $x \in \Delta$, je zagotovljeno, da lahko izraz dostopa le do veljavnih spremenljivk, kajti v nasprotnem primeru se izraz ne ujema z nobenim od pravil, zaradi česar prevajalnik vrne napako.

% Pravila za prenašanje lastništva
\begin{equation}
\infers[int]{}{
    \Delta; \, \texttt{n\#}
}{
    \Delta
}
\label{eq:int}
\end{equation}

\begin{equation}
\infers[var]{
    x \in \Delta
}{
    \Delta; \, x
}{
	\Delta \setminus \{ x \}
}
\label{eq:var}
\end{equation}

Pravili \ref{eq:app} in \ref{eq:primop} obravnavata aplikacije funkcij oziroma primitivnih operacij. Ker je $f$ spremenljivka, aplikacija prevzame lastništvo nad njo, prav tako pa se argumenti premaknejo v samo funkcijo. Pri klicu funkcije namreč parametrom $x_1, \dots, x_n$ implicitno priredimo vrednosti argumentov $a_1, \dots, a_n$ in jih s tem \emph{premaknemo} v telo funkcije. Podobno obravnavamo tudi primitivne operacije, le da pri tem premaknemo le argumente. Na tem mestu je potrebno poudariti, da s praviloma uvedemo vrstni red obdelave argumentov, ti se namreč v kontekst dodajo oziroma iz njega odstranijo od leve proti desni. Tako smo v len programski jezik z analizo premikov na nek način dodali vrstni red operacij, kar pa ni najbolj zaželeno.

\begin{equation}
\infers[app]{
    f \in \Delta \qquad \Delta_0 \coloneqq \Delta \setminus \{ f \} \qquad \Delta_0; \, a_1 \leadsto \Delta_1 \qquad \dots \qquad \Delta_{n-1}; \, a_n \leadsto \Delta_n
}{
    \Delta; \, f^k \, a_1 \dots a_n
}{
	\Delta_n
}
\label{eq:app}
\end{equation}

\begin{equation}
\infers[primop]{
    \Delta; \, a_1 \leadsto \Delta_1 \qquad \Delta_1; \, a_2 \leadsto \Delta_2 \qquad\dots \qquad \Delta_{n-1}; \, a_n \leadsto \Delta_n
}{
    \Delta; \, f^k \, a_1 \dots a_n
}{
	\Delta_n
}
\label{eq:primop}
\end{equation}

Pravilo \ref{eq:let} se ukvarja z \texttt{let} izrazi in sicer deluje na podoben način kot smo opisali na začetku poglavja \ref{sec:analiza-premikov}. Najprej se na kopici ustvari nov objekt, ki lahko prevzame lastništvo nad spremenljivkami v trenutnem kontekstu. Ker \texttt{let} izraz ni rekurziven, v kontekst $\Delta$ ne dodamo spremenljivke $x$. Spremenljivka $x$, ki je bila definirana v glavi izraza in preostale spremenljivke, ki še niso bile premaknjene (tj. tiste v $\Delta_1$) so lahko premaknjene v telesu \texttt{let} izraza.

\begin{equation}
\infers[let]{
    \Delta; \, \textit{obj} \leadsto \Delta_1
    \qquad
    \Delta_1 \cup \{ x \}; \, e \leadsto \Delta_2
}{
    \Delta; \, \texttt{let} \enspace x = \textit{obj} \enspace \texttt{in} \enspace e
}{
	\Delta_2
}
\label{eq:let}
\end{equation}

Pri pravilu \ref{eq:case}, se obravnava \texttt{case} izraz, pri katerem se najprej izvede izraz $e$, nato pa natanko ena izmed alternativ, kar pomeni, da lahko pri analizi premikov upoštevamo, da lahko alternative premaknejo enake spremenljivke. V novem kontekstu so torej vse tiste spremenljivke, ki niso bile premaknjene v nobeni izmed alternativ.

\begin{equation}
\infers[case]{
    \Delta; \, e \leadsto \Delta' \qquad \Delta'; \, alt_1 \leadsto \Delta_1 \qquad \dots \qquad \Delta'; \, alt_n \leadsto \Delta_n
}{
    \Delta; \, \texttt{case} \; e \; \texttt{of} \; \{ alt_1; \dots; alt_n \}
}{
	\Delta_1 \cap \dots \cap \Delta_n
}
\label{eq:case}
\end{equation}

V nadaljevanju podamo še pravila za analizo premikov objektov $obj$ in alternativ $alt$.

\begin{equation}
\infers[thunk]{
    \Delta; \, e \leadsto \Delta'
}{
    \Delta; \, \textsc{thunk}(e)
}{
	\Delta'
}
\label{eq:thunk}
\end{equation}

\begin{equation}
\infers[fun]{
    \Delta \cup \{ x_1, \dots, x_n \}; \, e \leadsto \Delta'
}{
    \Delta; \, \textsc{fun}(x_1 \dots x_n \to e)
}{
	\Delta'
}
\label{eq:fun}
\end{equation}

\begin{equation}
\infers[con]{
    \Delta_0; \, a_1 \leadsto \Delta_1
    \qquad
    \dots
    \qquad
    \Delta_{n - 1}; \, a_n \leadsto \Delta_n
}{
    \Delta_0; \, \textsc{con}(C \, a_1 \dots a_n)
}{
	\Delta_n
}
\label{eq:con}
\end{equation}

Objekta \textsc{pap} in \textsc{blackhole} se nikoli ne pojavita na desni strani izraza za prirejanje. Uporabljena sta za hranjenje stanja sistema in ju kot taka lahko na kopici ustvari samo izvajalno okolje. Ker se analiza premikov izvaja v času prevajanja, tako pravila za \textsc{pap} in \textsc{blackhole} niso potrebna.

\begin{equation}
\infers[conalt]{
    \Delta \cup \{ x_1, \dots, x_n \}; \, e \leadsto \Delta'
}{
    \Delta; \, C \enspace x_1 \; \dots \; x_n \to e
}{
	\Delta'
}
\label{eq:conalt}
\end{equation}

\begin{equation}
\infers[condef]{
    \Delta \cup \{ x \}; \, e \leadsto \Delta'
}{
    \Delta; \, x \to e
}{
	\Delta'
}
\label{eq:conalt}
\end{equation}

Alternative na podoben način kot \texttt{let} izrazi (pravilo \ref{eq:let}) in funkcije (pravilo \ref{eq:fun}) uvedejo nove spremenljivke.

S pravili analize premikov je v jeziku zagotovljeno, da je vsaka spremenljivka uporabljena \emph{največ enkrat}, kar ravno ustreza sistemu afinih tipov~\cite{pierce2004advanced}.

\subsection{Lastništvo objektov}

Sama analiza lastništva poskrbi, da je vsaka spremenljivka uporabljena naj\-več enkrat. Če program uspešno prestane analizo lastništva, torej velja, da na vsak objekt na kopici kaže naj\-več en kazalec. V tem poglavju bomo opisali sistem lastništva, ki je uporabljen med samim izvajanjem programa in skrbi za ustrezno čiščenje pomnilnika. Pri sistemu lastništva se z \komentar{unboxed} vrednostmi ne bomo ukvarjali, ker lahko te navadno spravimo v en register in je posledično njihovo kopiranje zelo preprosto in učinkovito.

Pri sistemu lastništva obravnavamo dva ločena pojma: spremenljivke in objekte. Objekti $obj$ so strukture (oziroma bolj specifično ovojnice) na kopici, ki so bile definirane v poglavju \ref{sec:stg-definicija}. Vsak objekt je lahko ena izmed petih možnosti (\textsc{thunk}, \textsc{fun}, \textsc{con}, \textsc{pap} ali \textsc{blackhole}) in je sestavljen iz kode, ki se izvede ob evalvaciji objekta in okolja, v katerem se hranijo vrednosti prostih spremenljivk. Pri uvedbi sistema lastništva, vsak objekt na kopici razširimo še s seznamom kazalcev na objekte, ki si jih le-ta lasti. V programskem jeziku Blang~\cite{turk2022len} tak seznam imenujejo za \textit{seznam močnih kazalcev}, zato bomo tako terminologijo uporabljali tudi mi. Med izvajanjem kode objekta, lahko pride do prenosa lastništva, pri čemer je potrebno seznam močnih kazalcev dopolniti z novo vrednostjo, oziroma kakšen kazalec odstraniti. Kadar se objekt do konca izračuna (npr. ko se \textsc{thunk} do konca evalvira), se sprosti pomnilnik vseh objektov na katere kažejo močni kazalci. Pri tem pa si tudi objekti na seznamu močnih kazalcev lastijo druge objekte, zaradi česar je potrebno operacijo sproščanja izvajati rekurzivno: vsak objekt na katerega kaže seznam iz močnih kazalcev najprej sprosti pomnilnik vseh objektov, ki si jih lasti, nato pa odstrani še sam sebe. V učinkoviti implementaciji bi vsak objekt poleg kode za izračun, vseboval še kodo za čiščenje pomnilnika, ki bi poskrbela za odstranjevanje vseh vrednosti, ki si jih lasti.

Kadar nek objekt ustvari novo spremenljivko $x$, tj. le s pomočjo \texttt{let} izraza, se na kopici ustvari nov objekt, njegov naslov pa se shrani v spremenljivko $x$. Ker je objekt spremenljivko ustvaril, je posledično tudi lastnik objekta na katerega spremenljivka kaže, zato se ob prirejanju v spremenljivko, v seznam močnih kazalcev doda še naslov objekta na katerega spremenljivka kaže.

V nadaljevanju bomo neformalno opisali pravila za prenašanje lastništva. Pri tem bomo upoštevali, da vsaka \emph{uporaba} neke spremenljivke, preda lastništvo objekta na katerega spremenljivka kaže, nekemu drugemu objektu.

\begin{itemize}
    \itemsep 0em
    \item Pri aplikaciji $f^k \: a_1 \dots a_n$ so argumenti atomarni, kar pomeni, da so ali \komentar{unboxed} vrednosti, pri katerih se z lastništvom ne ukvarjamo ali pa spremenljivke, ki kažejo na druge objekte na kopici. Lastništvo objektov na katere kažejo argumenti $a_1, \dots, a_n$ se preda objektu na katerega kaže spremenljivka $f$.
    \item Pri primitivnih operacijah $\oplus \: a_1 \dots a_n$, je zgodba podobna kot pri aplikaciji funkcij. Operator prevzame lastništvo nad objekti na katere kažejo argumenti $a_1, \dots, a_n$.
    \item Pri izrazu $\texttt{let} \enspace x = obj \enspace \texttt{in} \enspace e$ se na kopici najprej ustvari objekt $obj$, ki prevzame lastništvo nad vsemi prostimi spremenljivkami (tj. spremenljivkami v množici $\textit{free}(obj)$), ki se  objektu pojavijo. Izraz \texttt{let} uvede spremenljivko $x$, zato trenutni objekt prevzame lastništvo nad novonastalim objektom $obj$, nato pa se nadaljuje z izračunom telesa $e$.
    \item Pri \texttt{case} izrazu se najprej izračuna \komentar{scrutinee} izraz $e$, pri čemer lahko pride do prenosa lastništva. Rezultat je naslov $v$ konstruktorja \textsc{con}, ki se ujema z eno izmed alternativ. Če so vsi dosedanji izrazi lastništvo predali, pa ga \texttt{case} izraz prezvame. Trenutnemu objektu, se v seznam lastništva dodajo kazalci na vse objekte, ki si jih objekt $v$ lasti. Objekt na katerega kaže $v$, lahko izbrišemo iz pomnilnika, saj nanj zagotovo kaže le kazalec $v$.
\end{itemize}

\subsubsection{Sprememba operacijske semantike}

Operacijsko semantiko je potrebno dopolniti s pravili za čiščenje pomnilnika. V nadaljevanju neformalno opišemo nekaj najpomembnejših sprememb operacijske semantike.

\begin{itemize}
    \itemsep 0em
    \item Pravilo \ref{eq:stg-update} posodobi objekt \textsc{thunk} na kopici s preusmeritvijo \textsc{indirection}, ki kaže na objekt z rezultatom. Ker je pri tem \textsc{thunk} objekt uničen, lahko pri tem počistimo pomnilnik vseh objektov, ki si jih le-ta lasti.
    \item Pri pravilu \ref{eq:stg-casecon} trenuten objekt prevzame lastništvo nad vsemi argumenti konstruktorja. Zatem je lahko pomnilnik \textsc{con} objekta spro\-ščen, saj s tem vrednosti argumentov niso izbrisane pred uporabo. 
    \item Pri pravilu \ref{eq:stg-primop} najprej izračunamo rezultat primitivne operacije, nato pa lahko počistimo pomnilnik vseh objektov, ki so bili uporabljeni za izračun rezultata.
\end{itemize}

\subsubsection{Primer}

Naslednji program prikazuje zakasnitev $t$, ki ustvari dva nova objekta na kopici in ju priredi spremenljivkama $a$ in $b$. Pri prirejanju v spremenljivko $r$, sta spremenljivki $a$ in $b$ v telesu funkcije \emph{prosti}, kar pomeni, da se lastništvo (in s tem odgovornost za čiščenje pomnilnika) prenese v objekt \textsc{fun}. Telo najbolj vgnezdenega \texttt{let} izraza iz same zakasnitve $t$ vrne tudi lastništvo nad spremenljivko $r$. To pomeni, da \textsc{thunk} na katerega kaže spremenljivka $t$, ni več odgovoren za čiščenje pomnilnika nobene izmed spremenljivk, ki jih je definiral. Če program vsebuje kakršnokoli prirejanje, kjer se spremenljivka $t$ pojavi na desni strani (angl. right-hand-side), potem objekt v katerem se prirejanje nahaja, prevzame lastništvo nad objektom $\textsc{fun}(f \to f \: a \, b)$.

\begin{code-box}{haskell}{STG jezik s sistemom lastništva \cmark}
t = THUNK(
    let a = THUNK(...)      in
    let b = THUNK(...)      in
    let r = FUN(f -> f a b) in  -- Premik
        r
)
\end{code-box}

Ena izmed optimizacij, ki jo lahko prevajalnik izvede, da s pomočjo analize prostih spremenljivk prepozna katere izmed spremenljivk, definiranih v nekem objektu (z \texttt{let} izrazom) v nadaljevanju programa niso nikjer več uporabljene. Take definicije lahko prevajalnik iz programa odstrani ter s tem zmanjša količino objektov, ki se ustvarijo oziroma brišejo iz kopice.

\subsubsection{Prednosti in slabosti}

% Prednosti in slabosti jezika, ki vsebuje le premike
Prednost jezika STG, ki vsebuje le premike (tj. le sistem lastništva), je v tem, da lahko čiščenje pomnilnika izvajamo avtomatično, a brez uporabe avtomatičnega čistilca pomnilnika. Vsak objekt na kopici dopolnimo s seznamom objektov, ki si jih le-ta lasti, operacijsko semantiko jezika pa dopolnimo tako, da se ob posodobitvah zakasnitev, sprosti pomnilnik za objekte, ki so v seznamu. Slaba lastnost takega jezika je v tem, da s tem v jezik na nek način uvedemo sistem afinih tipov, s čemer v jezik uvedemo tudi omejitve, ki jih ima tak sistem. V takem jeziku lahko vsako spremenljivko (oziroma vsak objekt) uporabimo največ enkrat, kar pomeni, da ne moremo napisati naslednjega programa.

\begin{code-box}{haskell}{STG jezik \xmark}
main = THUNK(
    let a = ... in
    let b = CON(Pair a a) in -- (a, a)
        ...
)
\end{code-box}

Afinost sistema tipov pomeni, da je vsaka spremenljivka lahko uporabljena \emph{največ enkrat}, tj. nič ali enkrat. Če spremenljivka v nekem objektu ni nikjer uporabljena, potem lahko objekt, na katerega se le-ta sklicuje, izbrišemo s pomnilnika. Če je spremenljivka nekje uporabljena, potem se lastništvo prenese na nek drug objekt, ki postane odgovoren tudi za čiščenje pomnilnika.

Prav tako ne moremo napisati programa, ki isto funkcijo uporabi večkrat, kar pomeni, da izgubimo tudi možnost rekurzije.

% Možne rešitve:
%   * slabša: uvedemo izraz clone
%   * boljša: podobno kot v Rustu, dodamo izposojo

\section{Globoko kloniranje objektov}

Glavna težava, ki se pojavi pri sistemu, ki vsebuje le princip lastništva, je nezmožnost deljenja objektov. Ena izmed možnih rešitev (implementirana tudi v delu \cite{marshall2024functional}) je vpeljava izraza \texttt{clone}, ki zna globoko klonirati (angl. deep clone) objekt na kopici. Pri globokem kopiranju se ustvari nova kopija objekta, vključno z vsemi njegovimi notranjimi strukturami in podatki. To pomeni, da se rekurzivno kopirajo tudi vsi vgnezdeni objekti in podatkovne strukture, ki jih vsebuje izvorni objekt. Rezultat je popolnoma neodvisna kopija originalnega objekta, kjer spremembe na kopiji ne vplivajo na original in obratno.

S pomočjo analize premikov lahko tako za vsak objekt zagotovimo, da na vsak objekt kaže natanko ena referenca, s pomočjo kloniranja pa lahko objekte podvajamo, ne da bi to predpostavko prekršili. Slabost takega pristopa je v tem, da je pri kloniranju velikih oziroma bolj kompleksnih objektov, postopek kloniranja izredno časovno in prostorsko potraten~\cite{wadler1990linear, lafont1988linear}. Do druge težave pride zaradi same lenosti izračuna.

\begin{code-box}{haskell}{STG jezik z globokim kloniranjem \xmark}
main = THUNK(
    let a = ... in
    let b = THUNK(clone a) in
        (f a) + b
)
\end{code-box}

Zgornji primer prikazuje program, ki bi se v neučakanem jeziku izvedel brez težav. Ob prirejanju v spremenljivko \texttt{b}, bi se namreč celoten objekt na kopici, na katerega kaže spremenljivka \texttt{a}, kopiral, kar pomeni, da sta objekta na katera kažeta spremenljivki \texttt{a} in \texttt{b} povsem disjunktna (tj. njuna grafa na pomnilniku si ne delita nobenega vozlišča). Funkcija \texttt{f} prevzame lastništvo nad \texttt{a} in s tem tudi odgovornost za čiščenje pomnilnika. Če se v izrazu \texttt{(f a) + b} torej najprej izvede aplikacija $f a$, potem se pomnilnik spremenljivke $a$ tudi ustrezno počisti. Toda, spremenljivka $b$ kaže na zakasnitev, ki pa še ni bila izračunana, ta pa vsebuje referenco na sedaj neobstoječo spremenljivko $a$, kar pomeni, da pride pri izvajanju programa do napake.

Če bi želeli, da se program pravilno izračuna, bi torej morali v STG jezik ponovno uvesti neučakanost pri računanju, na podoben način kot je to pri \texttt{let!} izrazu Wadlerjevem jeziku s sistemom \komentar{steadfast} tipov~\cite{wadler1990linear}. Pri tem se desna stran prirejanja izračuna \emph{v celoti}, preden se izvede telo izraza, kar Wadler imenuje za hiperstriktni izračun (angl. hyperstrict evaluation). Ker je leni izračun osnova STG jezika, ta pristop ne pride v poštev.

\section{Izposoja}

Druga rešitev, s pomočjo katere lahko v programski jezik s sistemom lastništva ponovno uvedemo deljenje izrazov, temelji na Rustovem modelu izposoje.

% Kako bomo obravnavali izposoje?

\begin{code-box}{haskell}{STG jezik}
main = THUNK(
    let a = ... in
    let b = THUNK(... &a ...) in -- Izposoja
    let c = THUNK(... &a ...) in -- Izposoja
        ...
)
\end{code-box}

% V tem primeru ustvarimo 2 izposoji na spremenljivko \texttt{a}. Zaradi same lenosti jezika, ne vemo katera izmed zakasnitev se bo prej izračunala. Če upoštevamo, da funkcija \texttt{add} najprej izračuna vrednost levega argumenta, nato pa še desnega, potem bo izraz \texttt{add\ b\ c} najprej evalviral zakasnitev \texttt{b}, medtem ko bo izraz \texttt{add\ c\ b} najprej izračunal zakasnitev \texttt{c}. Edina stvar za katero smo prepričani je, da se bodo na kopici objekti ustvarili v vrstnem redu kot se pojavijo, tj. najprej \texttt{a}, nato \texttt{b} in nato \texttt{c}.

\begin{code-box}{haskell}{STG jezik}
main = THUNK(
    let a = ... in
    let b = THUNK(... a ...) in
    -- Neveljavna izposoja, spremenljivka a je bila že premaknjena
    let c = THUNK(... & a ...) in 
        ...
)
\end{code-box}

\begin{code-box}{haskell}{STG jezik}
main = THUNK(
    let a = ... in
    let b = THUNK(... & a ...) in
    -- Neveljaven premik, spremenljivka a je že bila izposojena
    let c = THUNK(... a ...) in
        ...
)
\end{code-box}

Zgornja dva primera upoštevata, da se lastništvo v objekt prenese kadar se objekt alocira na kopici. Na podoben način deluje sistem lastništva v Rustu.

\begin{code-box}{haskell}{STG jezik \cmark}
main = THUNK(
    let a = THUNK(...) in
    let r = CON(Just a) in
        r
)
\end{code-box}

\begin{code-box}{haskell}{STG jezik \xmark}
main = THUNK(
    let a = THUNK(...) in
    let r = CON(Pair a a) in
        r
)
\end{code-box}

\begin{code-box}{haskell}{STG jezik}
main = THUNK(
    let a = ... in
    let b = THUNK(... & a ...) in -- Izposoja
    let c = THUNK(... & a ...) in -- Izposoja
    let result = CON(Pair b c) in -- (& a, & a)
        result
        -- Lastništvo spremenljivke a ni bilo predano ven iz same
        -- zakasnitve `main`. Mi bi na tem mestu želeli počistiti
        -- pomnilnik spremenljivke `a`.
        -- Toda: imamo dve živi izposoji spremenljivke, kar pomeni
        -- da smo v program uvedli viseč kazalec.
)
\end{code-box}

Torej, ali je na nek način dovolj, če:

\begin{enumerate}
    \itemsep 0em
    \item izvedemo analizo premikov - vsaka spremenljivka je lahko premaknjena (tj. na nek način uporabljena) natanko enkrat. Ko je enkrat premaknjena (glede na vrstni red \texttt{let} izrazov), v nadaljevanju ne sme več biti uporabljena.
    \item izvedemo analizo izposoj, pri kateri preverimo ali je spremenljivka, ki je bila ustvarjena znotraj neke zakasnitve vrnjena ven iz neke zakasnitve. Pri posodobitvi zakasnitve bi namreč želeli počistiti pomnilnik vseh spremenljivk, ki so bile v zakasnitvi ustvarjene (tj. definirane s pomočjo \texttt{let} izraza) in niso bile premaknjene izven te zakasnitve (kot rezultat nekega izraza).
\end{enumerate}

Zdi se, da lahko s temi pravili pokrijemo vse dosedanje primere. Toda kaj pa v primerih, v katerih vračamo hkrati lastništo in izposojo na isti objekt?

\begin{code-box}{haskell}{STG jezik}
pair = THUNK(
    let a = ... in
    let b = THUNK(... &a ...) in -- Izposoja
    let result = CON(Pair a b) in -- (a, & a)
        result
        -- Spremenljivka a je bila premaknjena ven iz zakasnitve,
        -- ki jo je ustvarila. Za čiščenje postane odgovoren
        -- klicatelj funkcije `pair`. Iz funkcije pa spustimo še
        -- izposojo spremenljivke a, kar je v tem primeru
        -- smiselno, saj vemo, da je spremenljivka `a`
        -- (vsaj v tem trenutku) živa več časa kot njena izposoja.
        -- Objekt `CON` prevzame lastništvo nad spremenljivko `a`,
        -- funkcija `func` ni več odgovorna za čiščenje
        -- pomnilnika.
)
\end{code-box}

\begin{code-box}{haskell}{STG jezik}
example = THUNK(
    case pair of {
        Pair left right ->
            -- Objekt THUNK (funkcije `example`) prevzame
            -- lastništvo nad obema spremenljivkama znotraj
            -- konstruktorja CON. Ta ni več odgovoren za
            -- čiščenje pomnilnika.
            --   left  := a
            --   right := & a
            -- Tukaj je potrebno zagotoviti, da spremenljivka
            -- `left` živi dlje od njene izposoje `right`
    }
)
\end{code-box}

Kako lahko v tem primeru prevajalnik ugotovi, da mora spremenljivka \texttt{left} živeti dlje od spremenljivke \texttt{right}? Na nek način bi bilo potrebno uvesti življenjske dobe. Tako bi npr. lahko rezultat zakasnitve \texttt{pair} označili z naslednjo oznako.

\begin{code-box}{haskell}{STG jezik}
pair :: forall 'a => forall 'b <= 'a => Pair 'a 'b
\end{code-box}

Iz te je razvidno, da je ta vsebuje dva tipa \texttt{'a} in \texttt{'b}, za katera velja $'b \, \sqsubseteq \, 'a$, tj. da je \texttt{'a} vsaj tako dolg, kot je \texttt{'b}, oziroma da \texttt{'a} preživi \texttt{'b}. Toda, s tem v jezik STG ponovno uvedemo analizo tipov, česar pa ne želimo, saj sam jezik nima dovolj podatkov, da bi lahko izvedli izpeljavo oziroma preverjanje tipov.

\komentar{Ne znam poiskati dovolj dobrega programa, s katerim bi na enostaven način lahko pokazal zakaj zadeva ni mogoča}

\section{Odkrivanje tople vode - štetje referenc}

Slika \ref{fig:povezani-seznami} prikazuje implementacijo povezanega seznama s pomočjo deljenja objektov v STG jeziku.

\begin{figure*}[ht]
	\centering
	\begin{tikzpicture}[y=-1cm,scale=0.7]
        \node at (-1.75, 0.5) {$a$};
        \draw[-Latex] (-1.25, 0.5) -- (0, 0.5);
        
        \node at (-1.75, 2.5) {$b$};
        \draw[-Latex] (-1.25, 2.5) -- (0, 2.5);
        
        \draw (0, 0) rectangle ++(1, 1);
        \draw (1, 0) rectangle ++(1, 1);
        
        \draw (3, 0) rectangle ++(1, 1);
        \draw (4, 0) rectangle ++(1, 1);

        \draw (6, 0) rectangle ++(1, 1);
        \draw (7, 0) rectangle ++(1, 1);
        
        \draw (9, 0) rectangle ++(1, 1);
        \draw (10, 0) rectangle ++(1, 1);

        \draw[{Circle}-Latex] (1.5, 0.5) -- (3, 0.5);
        \draw[{Circle}-Latex] (4.5, 0.5) -- (6, 0.5);
        \draw[{Circle}-Latex] (7.5, 0.5) -- (9, 0.5);
        \draw[{Circle}-Latex] (10.5, 0.5) -- (12, 0.5);
        \node at (12.75, 0.5) {\texttt{nil}};

        \draw (0, 2) rectangle ++(1, 1);
        \draw (1, 2) rectangle ++(1, 1);

        \draw (3, 2) rectangle ++(1, 1);
        \draw (4, 2) rectangle ++(1, 1);
        \draw[{Circle}-Latex] (1.5, 2.5) -- (3, 2.5);
        % \draw[{Circle}-] (4.5, 2.5) -- (8.5, 2.5) -- (8.5, 0.5);
         \draw [{Circle}-Latex] (4.5, 2.5) .. controls (8, 2.5) and (8, 0.75) .. (9, 0.75);
	\end{tikzpicture}
	\caption{Implementacija povezanega seznama z deljenjem objektov na kopici (angl. sharing)}
	\label{fig:povezani-seznami}
\end{figure*}

\komentar{Opišemo, da ker kažeta na objekt dva kazalca, morata vedeti en za drugega. Ko gre prvi izven dosega, mora sporočiti drugemu, da je sedaj on lastnik. Na tak način pridemo ravno do štetja referenc po obratni strani, kar je dosti manj učinkovito.}

% TODO: Napiši bolje
% Zaradi lenosti jezika je izračun življenjskih dob praktično nemogoč, kar pomeni, da Rustov princip čiščenja pomnilnika ne pride v poštev. Ker ne moremo izračunati življenjskih dob, v STG ne moremo implementirati izposoje. Kar se tiče pa samega lastništva iz Rusta, je pa to zelo podobno linearnim oziroma edinstvenim tipom (angl. uniqueness types). Ti so bili v Haskell že implementirani (glej "Linear Haskell: practical linearity in a higher-order polymorphic language"~\cite{bernardy2018linear}). Če v jezik uvedemo le linearne tipe, jezik zelo omejimo in postane dokaj neuporaben. Zato navadno dodamo še nelinearne tipe, zaradi katerih pa: 1. jezik ni več povsem len (glej poglavje 3.1.1) 2. v jeziku še vedno potrebujemo avtomatičen čistilec pomnilnika (linearne tipe lahko počistimo brez, nelinearnih pa na žalost ne)

% \section{Primer}

% Za vsakršno vrsto analize je potrebno v jezik STG ponovno potrebno uvesti oznake tipov.
% Zakaj

% Kdo ima lastništvo?
%\begin{code-box}{haskell}{STG jezik}
%main = THUNK(
%    let a = ... in
%    let f = FUN(x -> add x &a) in
%    let result = CON(Just f) in
%        result
%)
%\end{code-box}

%Hočemo primer

%\begin{code-box}{haskell}{STG}
%let a = ...
%let b = THUNK(&a)
%-- Tukaj bi radi nekako pokazali, da ne vemo kdo bo dlje živel.
%-- Ker če živi b dlje od a => viseči kazalci

%-- Pokličemo funkcijo f :: &'a A -> &'a A
%-- V Rustu vse lepo in prav, funkcija se nemudoma izvede, zgodba
%-- je končana.
%let r = THUNK(f b)
%let result = CON(Just r)
%\end{code-box}

%\begin{code-box}{haskell}{STG}
%f :: &'a A -> &'static int
%
%
%let a = ... in
%let b = THUNK(&a) in
%let c = THUNK(f a) in
%    c
%let first = CON(Just &a)
%\end{code-box}