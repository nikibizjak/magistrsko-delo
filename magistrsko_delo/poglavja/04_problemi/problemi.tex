\chapter[Življenjske dobe in leni izračun]{Težave pri izračunu življenjskih dob pri lenem izračunu}

Programski jezik Rust je neučakan, kar pomeni, da je vrstni red operacij v programu natanko določen. Če se stavek $s_1$ v programu pojavi pred stavkom $s_2$, potem se bo stavek $s_1$ zagotovo izvedel pred $s_2$.

V spodnjem primeru se bodo stavki zagotovo izvajali glede na vrstni red, v katerem so zapisani. Tako se bo klic funkcije \texttt{mul} zagotovo izvedel pred klicem \texttt{div}, ta pa se bo zagotovo izvedla pred klicem \texttt{add}.

\begin{rust-success}
fn izracunaj() -> i32 {
    let a = mul(6, 2);
    let b = div(8, 2);
    let r = add(b, a);
    return r;
}
\end{rust-success}

% Opis kako bi se to izvedlo v lenem izračunu
V jezikih z lenim izračunom pa temu ni tako. Pri prirejanju v spremenljivko $a$, bi se na kopici najprej ustvarila nova zakasnitev za poznejši izračun vrednosti izraza \texttt{mul(6, 2)}. V spremenljivki $a$ bi se hranil kazalec na naslov na katerem se nahaja zakasnitev. Na podoben način bi se izvedlo še prirejanje v $b$, pri prirejanju v spremenljivko $r$ pa bi se v ovojnico zakasnitve shranila še kazalca na zakasnitvi $a$ in $b$ a kopici. Ker je izračun len, se pri klicu funkcije \texttt{izracunaj} na kopici samo ustvarijo novi objekti, ne izračuna pa se njihova dejanska vrednost. Rezultat klica \texttt{izracunaj} je tako naslov ovojnice zakasnitve $r$ na kopici. 

% Življenjske dobe.
% Če predpostavimo, da se v Rustu življenjske dobe računajo leksikalno.
Ker je vrstni red operacij natanko določen, je zelo preprosto izračunati tudi življenjske dobe. V zgornjem primeru ima spremenljivka $a$ zagotovo daljšo življenjsko spremenljivko $b$, saj je bila deklarirana pred uvedbo spremenljivke $b$. Ker bi se spremenljivka $b$ lahko sklicevala na spremenljivko $a$, je potrebno zagotoviti, da spremenljivka $a$ živi vsaj toliko časa kot $b$, kar pomeni da je življenjska doba spremenljivke $a$ večja od $b$.

% TODO: Napiši bolje
Zaradi lenosti jezika je izračun življenjskih dob praktično nemogoč, kar pomeni, da Rustov princip čiščenja pomnilnika ne pride v poštev. Ker ne moremo izračunati življenjskih dob, v STG ne moremo implementirati izposoje. Kar se tiče pa samega lastništva iz Rusta, je pa to zelo podobno linearnim oziroma edinstvenim tipom (angl. uniqueness types). Ti so bili v Haskell že implementirani (glej "Linear Haskell: practical linearity in a higher-order polymorphic language"~\cite{bernardy2018linear}). Če v jezik uvedemo le linearne tipe, jezik zelo omejimo in postane dokaj neuporaben. Zato navadno dodamo še nelinearne tipe, zaradi katerih pa: 1. jezik ni več povsem len (glej poglavje 3.1.1) 2. v jeziku še vedno potrebujemo avtomatičen čistilec pomnilnika (linearne tipe lahko počistimo brez, nelinearnih pa na žalost ne)