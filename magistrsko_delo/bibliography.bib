@article{10.1145/72551.72554,
	author     = {Hudak, Paul},
	title      = {Conception, Evolution, and Application of Functional Programming Languages},
	year       = {1989},
	month      = {9},
	issue_date = {Sep. 1989},
	publisher  = {Association for Computing Machinery},
	address    = {New York, NY, USA},
	volume     = {21},
	number     = {3},
	journal    = {ACM Computing Surveys},
	pages      = {359–411},
	numpages   = {53}
}

@inproceedings{brus1987clean,
	title        = {Clean --- A language for functional graph rewriting},
	author       = {Brus, Tom H and van Eekelen, Marko CJD and Van Leer, MO and Plasmeijer, Marinus J},
	booktitle    = {Functional Programming Languages and Computer Architecture: Portland, Oregon, USA, September 14--16, 1987 Proceedings},
	pages        = {364--384},
	year         = {1987},
	month        = {9},
	organization = {Springer}
}

@article{collins1960method,
	author     = {Collins, George E.},
	title      = {A Method for Overlapping and Erasure of Lists},
	year       = {1960},
	issue_date = {Dec. 1960},
	publisher  = {Association for Computing Machinery},
	address    = {New York, NY, USA},
	volume     = {3},
	number     = {12},
	journal    = {Communications of the {ACM}},
	month      = {12},
	pages      = {655--657},
	numpages   = {3}
}

@article{czaplicki2012elm,
	title   = {Elm : Concurrent {FRP} for Functional {GUI}s},
	author  = {Czaplicki, Evan},
	journal = {Senior thesis, Harvard University},
	volume  = {30},
	year    = {2012}
}

@article{fenichel1969lisp,
	title     = {A {LISP} garbage-collector for virtual-memory computer systems},
	author    = {Fenichel, Robert R and Yochelson, Jerome C},
	journal   = {Communications of the ACM},
	volume    = {12},
	number    = {11},
	pages     = {611--612},
	year      = {1969},
	publisher = {ACM New York, NY, USA}
}

@inproceedings{GHC,
	author    = {Jones, SL Peyton and Hammond, K and Partain, WD and Wadler, PL and Hall, CV and Peyton Jones, Simon},
	title     = {The {Glasgow} {Haskell} {Compiler}: a technical overview},
	year      = {1993},
	month     = {3},
	publisher = {DTI/SERC},
	pages     = {249-257},
	booktitle = {Proceedings of Joint Framework for Information Technology Technical Conference, Keele}
}

% STG - original (push, enter)
@article{jones1992implementing,
	title     = {{Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine}},
	author    = {Jones, Simon L Peyton},
	journal   = {Journal of functional programming},
	volume    = {2},
	number    = {2},
	pages     = {127--202},
	year      = {1992},
	publisher = {Cambridge University Press}
}

@article{jones1992tail,
	title={Tail recursion without space leaks},
	author={Jones, Richard},
	journal={Journal of Functional Programming},
	volume={2},
	number={1},
	pages={73--79},
	year={1992},
	publisher={Cambridge University Press}
}

% STG - improved (eval, apply)
@book{jones2023garbage,
	title     = {The garbage collection handbook: the art of automatic memory management},
	author    = {Jones, Richard and Hosking, Antony and Moss, Eliot},
	year      = {2023},
	publisher = {CRC Press}
}

% Miranda
@phdthesis{Jung,
	title  = {Understanding and evolving the {Rust} programming language},
	author = {Jung, Ralf},
	year   = {2020},
	school = {Saarland University}
}

% Elm
@book{klabnik2023rust,
	title     = {The Rust Programming Language, 2nd Edition},
	author    = {Klabnik, S. and Nichols, C.},
	year      = {2023},
	publisher = {No Starch Press}
}

% Clean
@mastersthesis{Kocjan_Turk_2022,
	title  = {Len funkcijski programski jezik brez čistilca pomnilnika},
	school = {Univerza v Ljubljani},
	author = {Kocjan Turk, Toni},
	year   = {2022}
}

% F#
@article{marlow2004making,
	title     = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
	author    = {Marlow, Simon and Jones, Simon Peyton},
	journal   = {ACM SIGPLAN Notices},
	volume    = {39},
	number    = {9},
	pages     = {4--15},
	year      = {2004},
	publisher = {ACM New York, NY, USA}
}

% Scheme
@article{mccarthy1960recursive,
	title     = {Recursive functions of symbolic expressions and their computation by machine, part {I}},
	author    = {McCarthy, John},
	journal   = {Communications of the ACM},
	volume    = {3},
	number    = {4},
	pages     = {184--195},
	year      = {1960},
	publisher = {ACM New York, NY, USA}
}

@article{Oxide,
	title   = {Oxide: The essence of {Rust}},
	author  = {Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Ahmed, Amal},
	journal = {arXiv preprint arXiv:1903.00982},
	year    = {2019}
}


% Toni  Kocjan Turk
@book{peyton1987implementation,
	title     = {The implementation of functional programming languages (prentice-hall international series in computer science)},
	author    = {Peyton Jones, Simon L},
	year      = {1987},
	publisher = {{Prentice-Hall, Inc.}}
}

% Grin compiler
@article{podlovics2022modern,
	title     = {A modern look at {GRIN}, an optimizing functional language back end},
	author    = {Podlovics, Peter and Hruska, Csaba and P{\'e}nzes, Andor},
	journal   = {Acta Cybernetica},
	volume    = {25},
	number    = {4},
	pages     = {847--876},
	year      = {2022},
	publisher = {University of Szeged}
}

% Garbage collection - Haskell
@inproceedings{sansom1993generational,
	title     = {{Generational garbage collection for Haskell}},
	author    = {Sansom, Patrick M and Peyton Jones, Simon L},
	booktitle = {Proceedings of the conference on Functional programming languages and computer architecture},
	pages     = {106--116},
	year      = {1993}
}

% Haskell - Garbage collection
@article{sperber2009revised6,
	title     = {{Revised6 report on the algorithmic language Scheme}},
	author    = {Sperber, Michael and Dybvig, R Kent and Flatt, Matthew and Van Straaten, Anton and Findler, Robby and Matthews, Jacob},
	journal   = {Journal of Functional Programming},
	volume    = {19},
	number    = {S1},
	pages     = {1--301},
	year      = {2009},
	publisher = {Cambridge University Press}
}


% Rust
@article{StackedBorrows,
	title     = {Stacked borrows: an aliasing model for Rust},
	author    = {Jung, Ralf and Dang, Hoang-Hai and Kang, Jeehoon and Dreyer, Derek},
	journal   = {Proceedings of the ACM on Programming Languages},
	volume    = {4},
	number    = {POPL},
	pages     = {1--32},
	year      = {2019},
	publisher = {ACM New York, NY, USA}
}

@misc{syme2017the,
	author    = {Syme, Don},
	title     = {The F\# Compiler Technical Overview},
	year      = {2017},
	month     = {3},
	publisher = {The F\# Software Foundation Core Engineering Group}
}

@inproceedings{turner1985miranda,
	title        = {Miranda: A non-strict functional language with polymorphic types},
	author       = {Turner, David A},
	booktitle    = {Conference on Functional Programming Languages and Computer Architecture},
	pages        = {1--16},
	year         = {1985},
	organization = {Springer}
}

@inproceedings{LLVM:CGO04,
	author    = {Chris Lattner and Vikram Adve},
	title     = {{LLVM}: A Compilation Framework for Lifelong Program 
	Analysis and Transformation},
	booktitle = CGO,
	address   = {San Jose, CA, USA},
	month     = {3},
	year      = {2004},
	pages     = {75--88}
}

@inproceedings{boquist1997grin,
	title        = {The {GRIN} project: A highly optimising back end for lazy functional languages},
	author       = {Boquist, Urban and Johnsson, Thomas},
	booktitle    = {{Implementation of Functional Languages: 8th International Workshop, IFL'96 Bad Godesberg, Germany, September 16--18, 1996 Selected Papers 8}},
	pages        = {58--84},
	year         = {1997},
	organization = {Springer}
}

@techreport{proust2017asap,
	title       = {{ASAP}: As static as possible memory management},
	author      = {Proust, Rapha{\"e}l L},
	year        = {2017},
	institution = {University of Cambridge, Computer Laboratory}
}

@article{boquist1999code,
	title   = {Code optimization techniques for lazy functional languages},
	author  = {Boquist, Urban},
	journal = {Doktorsavhandlingar vid Chalmers Tekniska Hogskola},
	number  = {1495},
	pages   = {1--331},
	year    = {1999}
}

@techreport{corbyn:practical-static-memory-management,
	title       = {Practical Static Memory Management},
	author      = {Corbyn, Nathan},
	year        = {2020},
	institution = {University of Cambridge},
	note        = {{BA} Dissertation}
}

@book{scott2016programming,
	title     = {Programming language pragmatics},
	author    = {Scott, Michael},
	year      = {2016},
	edition   = {4},
	publisher = {Morgan Kaufmann}
}

@inproceedings{flanagan1993essence,
	title={The essence of compiling with continuations},
	author={Flanagan, Cormac and Sabry, Amr and Duba, Bruce F and Felleisen, Matthias},
	booktitle={Proceedings of the ACM SIGPLAN 1993 conference on Programming language design and implementation},
	pages={237--247},
	year={1993}
}

@article{orchard2019quantitative,
	title={Quantitative program reasoning with graded modal types},
	author={Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
	journal={Proceedings of the ACM on Programming Languages},
	volume={3},
	number={ICFP},
	pages={1--30},
	year={2019},
	publisher={ACM New York, NY, USA}
}

@article{10.1145/3649848,
	author = {Marshall, Daniel and Orchard, Dominic},
	title = {Functional Ownership through Fractional Uniqueness},
	year = {2024},
	issue_date = {April 2024},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {8},
	number = {OOPSLA1},
	url = {https://doi.org/10.1145/3649848},
	doi = {10.1145/3649848},
	journal = {Proc. ACM Program. Lang.},
	month = {apr},
	articleno = {131},
	numpages = {31},
	keywords = {borrowing, fractional permissions, graded modal types, ownership}
}

@misc{Matsakis_2018,
	url={https://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/},
	journal={An alias-based formulation of the borrow checker}, author={Matsakis, Niko},
	year={2018}
}

@misc{Matsakis_et_al_2022,
	title={Non-lexical lifetimes (NLL) fully stable: Rust blog},
	url={https://blog.rust-lang.org/2022/08/05/nll-by-default.html}, 
	journal={The Rust Programming Language Blog}, 
	author={Matsakis, Niko and Nethercote, Nick and Faria, Paul  Daniel and Rakic, Rémy and Wood, David and Jasper, Matthew and Pastorino, Santiago and Klock, Felix},
	year={2022},
	month={Aug}
} 

@article{reed2015patina,
	title={Patina: A formalization of the Rust programming language},
	author={Reed, Eric},
	journal={University of Washington, Department of Computer Science and Engineering, Tech. Rep. UW-CSE-15-03-02},
	volume={264},
	year={2015}
}

@article{10.1145/3158154,
	author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
	title = {RustBelt: securing the foundations of the Rust programming language},
	year = {2017},
	issue_date = {January 2018},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {2},
	number = {POPL},
	url = {https://doi.org/10.1145/3158154},
	doi = {10.1145/3158154},
	abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
	journal = {Proc. ACM Program. Lang.},
	month = {dec},
	articleno = {66},
	numpages = {34},
	keywords = {type systems, separation logic, logical relations, concurrency, Rust}
}

@InProceedings{10.1007/978-3-030-99336-8_13,
	author="Marshall, Daniel
	and Vollmer, Michael
	and Orchard, Dominic",
	editor="Sergey, Ilya",
	title="Linearity and Uniqueness: An Entente Cordiale",
	booktitle="Programming Languages and Systems",
	year="2022",
	publisher="Springer International Publishing",
	address="Cham",
	pages="346--375",
	abstract="Substructural type systems are growing in popularity because they allow for a resourceful interpretation of data which can be used to rule out various software bugs. Indeed, substructurality is finally taking hold in modern programming; Haskell now has linear types roughly based on Girard's linear logic but integrated via graded function arrows, Clean has uniqueness types designed to ensure that values have at most a single reference to them, and Rust has an intricate ownership system for guaranteeing memory safety. But despite this broad range of resourceful type systems, there is comparatively little understanding of their relative strengths and weaknesses or whether their underlying frameworks can be unified. There is often confusion about whether linearity and uniqueness are essentially the same, or are instead `dual' to one another, or somewhere in between. This paper formalises the relationship between these two well-studied but rarely contrasted ideas, building on two distinct bodies of literature, showing that it is possible and advantageous to have both linear and unique types in the same type system. We study the guarantees of the resulting system and provide a practical implementation in the graded modal setting of the Granule language, adding a third kind of modality alongside coeffect and effect modalities. We then demonstrate via a benchmark that our implementation benefits from expected efficiency gains enabled by adding uniqueness to a language that already has a linear basis.",
	isbn="978-3-030-99336-8"
}

@article{10.1145/72551.72554,
	author = {Hudak, Paul},
	title = {Conception, evolution, and application of functional programming languages},
	year = {1989},
	issue_date = {Sep. 1989},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {21},
	number = {3},
	issn = {0360-0300},
	url = {https://doi.org/10.1145/72551.72554},
	doi = {10.1145/72551.72554},
	abstract = {The foundations of functional programming languages are examined from both historical and technical perspectives. Their evolution is traced through several critical periods: early work on lambda calculus and combinatory calculus, Lisp, Iswim, FP, ML, and modern functional languages such as Miranda1 and Haskell. The fundamental premises on which the functional programming methodology stands are critically analyzed with respect to philosophical, theoretical, and pragmatic concerns. Particular attention is paid to the main features that characterize modern functional languages: higher-order functions, lazy evaluation, equations and pattern matching, strong static typing and type inference, and data abstraction. In addition, current research areas—such as parallelism, nondeterminism, input/output, and state-oriented computations—are examined with the goal of predicting the future development and application of functional languages.},
	journal = {ACM Comput. Surv.},
	month = {sep},
	pages = {359–411},
	numpages = {53}
}

@inproceedings{van2007python,
	title={Python programming language.},
	author={Van Rossum, Guido and others},
	booktitle={USENIX annual technical conference},
	volume={41},
	number={1},
	pages={1--36},
	year={2007},
	organization={Santa Clara, CA}
}