%================================================================
% SLO
%----------------------------------------------------------------
% datoteka: 	thesis_template.tex
%
% opis: 		predloga za pisanje diplomskega dela v formatu LaTeX na
% 				Univerza v Ljubljani, Fakulteti za računalništvo in informatiko
%
% pripravili: 	Matej Kristan, Zoran Bosnić, Andrej Čopar,
%			  	po začetni predlogi Gašperja Fijavža
%
% popravil: 	Domen Rački, Jaka Cikač, Matej Kristan
%
% verzija: 		30. september 2016 (dodan razširjeni povzetek)
%================================================================


%================================================================
% SLO: definiraj strukturo dokumenta
% ENG: define file structure
%================================================================
\documentclass[a4paper, 12pt]{book}
 

%================================================================
% SLO: Odkomentiraj "\SLOtrue " za izbiro slovenskega jezika
% ENG: Uncomment "\SLOfalse" to chose English languagge
%================================================================
\newif\ifSLO
\newif\ifTRACKEXIST
\newif\ifTRACKCS
\newif\ifPROGRAMMM

% ---------------------------------------------------------------------------------------
% IMPORTANT: Adjust the thesis language, your study program and course within this block
% ---------------------------------------------------------------------------------------
% switch language
\SLOtrue % Enables Slovenian language
% \SLOfalse  % Enables English language

% switch programs: Computer science and Multimedia. Set to false if the program is in Multimedia
\PROGRAMMMfalse
% \PROGRAMMMtrue

% switch on if your program is divided into tracks CS and DS, otherwise leave it false
% CAUTION: if you were first enrolled into your program before school year 2019/2020, your program is not divided into tracks. In any case, be absolutely sure you select the correct variant. IF IN DOUBT, always contact the student office to advise you.
%
% \TRACKEXISTfalse
\TRACKEXISTtrue

% default course name is "Computer science" if your course name is "Data science", set the following switch to false
\TRACKCStrue % uncomment if the thesis is from course "Information science"
%\TRACKCSfalse % uncomment if the thesis is from course "Data Science"
% -------------------------------------------------------------------------------------------
% End of language, program and course adjustment
% -------------------------------------------------------------------------------------------


%================================================================
% SLO: vključi oblikovanje in pakete
% ENG: include design and packages
%================================================================
\input{style/thesis_style}

\newcommand{\ttitle}{Lastništvo objektov namesto avtomatskega čistilca pomnilnika med lenim izračunom}
\newcommand{\ttitleEn}{Ownership model instead of garbage collection during lazy evaluation}
\newcommand{\tsubject}{\ttitle}
\newcommand{\tsubjectEn}{\ttitleEn}
\newcommand{\tauthor}{Niki Bizjak}
\newcommand{\temail}{nb2020@student.uni-lj.si}
\newcommand{\myyear}{2023}
\newcommand{\tkeywords}{prevajalnik, nestrog izračun, upravljanje s pomnilnikom, avtomatični čistilec pomnilnika, lastništvo objektov}
\newcommand{\tkeywordsEn}{compiler, lazy evaluation, memory management, garbage collector, ownership model}
\newcommand{\mysupervisor}{doc.~dr.\ Boštjan Slivnik}
\newcommand{\mycosupervisor}{}

% include formatted front pages
\input{style/thesis_front_pages}

%================================================================
% ENG: main pages of the thesis
%================================================================

%----------------------------------------------------------------
% Poglavje (Chapter) 1
%----------------------------------------------------------------
\chapter{Uvod}
\label{ch:uvod}

Pomnilnik je dandanes kljub uvedbi pomnilniške hierarhije še vedno eden izmed najpočasnejših delov računalniške arhitekture. Učinkovito upravljanje s pomnilnikom je torej ključnega pomena za učinkovito izvajanje programov. Upravljanje s pomnilnikom v grobem ločimo na ročno in avtomatično~\cite{jones2023garbage}. Pri ročnem upravljanju s pomnilnikom programski jezik vsebuje konstrukte za dodeljevanje in sproščanje pomnilnika. Odgovornost upravljanja s pomnilnikom leži na programerju, zato je ta metoda podvržena človeški napaki. Pogosti napaki sta puščanje pomnilnika (angl. memory leaking), pri kateri dodeljen pomnilnik ni sproščen, in viseči kazalci (angl. dangling pointers), ki kažejo na že sproščene in zato neveljavne dele pomnilnika~\cite{jones2023garbage}.

Pri avtomatičnem upravljanju s pomnilnikom zna sistem sam dodeljevati in sproščati pomnilnik. Tukaj ločimo posredne in neposredne metode. Ena izmed neposrednih metod je npr. štetje referenc~\cite{collins1960method}, pri kateri za vsak objekt na kopici hranimo metapodatek o številu kazalcev, ki se sklicujejo nanj. V tem primeru moramo ob vsakem spreminjanju referenc zagotavljati še ustrezno posodabljanje števcev, kadar pa število kazalcev pade na nič, objekt izbrišemo iz pomnilnika. Posredne metode, npr. označi in pometi~\cite{mccarthy1960recursive}, ne posodabljajo metapodatkov na pomnilniku ob vsaki spremembi, temveč se izvedejo le, kadar se prekorači velikost kopice. Algoritem pregleda kopico in ugotovi, na katere objekte ne kaže več noben kazalec ter jih odstrani. Nekateri algoritmi podatke na kopici tudi defragmentirajo in s tem zagotovijo boljšo lokalnost ter s tem boljše predpomnjenje~\cite{fenichel1969lisp}.

Avtomatično čiščenje pomnilnika pa ima tudi svoje probleme. Štetje referenc v primeru pomnilniških ciklov privede do puščanja pomnilnika, metoda označi in pometi pa nedeterministično zaustavi izvajanje glavnega programa in tako ni primerna za časovno-kritične (angl. real-time) aplikacije. Kot alternativa obem načinom upravljanja s pomnilnikom sistemski programski jezik Rust implementira model lastništva~\cite{klabnik2023rust}. Med \textit{prevajanjem} zna s posebnimi pravili zagotoviti, da se pomnilnik objektov na kopici avtomatično sprosti, kadar jih program več ne potrebuje. To pa zna storiti brez čistilca pomnilnika in brez eksplicitnega dodeljevanja in sproščanja pomnilnika, zato zagotavlja predvidljivo sproščanje pomnilnika.

V magistrskem delu se bomo primarno ukvarjali s STG jezikom. Operacijska semantika tega veleva, da so vsi izrazi v izvorni kodi v pomnilniku predstavljeni kot zaprtja. Jezik vsebuje izraz \texttt{let}, ki na kopici ustvari novo zaprtje, izbirni izraz \texttt{case} pa šele dejansko izračuna njegovo vrednost. Jezik STG za čiščenje zaprtij iz kopice uporablja generacijski čistilec pomnilnika~\cite{jones1992implementing, marlow2004making}. 

Cilj magistrske naloge je pripraviti simulator STG stroja, nato pa spremeniti STG jezik tako, da bo namesto avtomatičnega čistilca pomnilnika uporabljal model lastništva po zgledu programskega jezika Rust. Zanimalo nas bo, kakšne posledice to v STG stroj prinese, kakšne omejitve se pri tem pojavijo ter do kakšnih problemov lahko pri tem pride. Zavedati se moramo, da obstaja možnost, da koncepta lastništva ni mogoče vpeljati v STG stroj brez korenitih sprememb zasnove stroja samega - v tem primeru bomo podali analizo, zakaj lastništva v STG stroj ni mogoče vpeljati.

% POGLAVJE: PREGLED PODROČJA
\include{poglavja/pregled_podrocja/pregled_podrocja.tex}

\chapter{Implementacija}
\label{ch:implementacija}

% Naša prevajalnik temelji na 
% Naš prevajalnik:
%   * razčlenjevanje (angl. parsing)
%   * semantična analiza

V fazi semantične analize prevajalnik izvede najprej razreševanje imen (angl. name resolution), ki mu sledita analiza izposoj (angl. borrow check) in premikov (angl. move check).

Pri razreševanju imen prevajalnik preveri, ali so vsa imena spremenljivk definirana pred njihovo uporabo. Prevajalnik se v tej fazi rekurzivno sprehodi čez abstraktno sintaksno drevo STG jezika. Pri tem vzdržuje kontekst trenutno živih spremenljivk. Pri uporabi spremenljivk prevajalnik preveri, ali se ime nahaja v kontekstu in v nasprotnem primeru vrne napako. Če se proces razreševanja imen zaključi brez napake, je zagotovljeno, da tekom izvajanja programa ne bo prišlo do napake zaradi uporabe nedefinirane spremenljivke.

Pri analizi izposoj prevajalnik zagotovi, da izposoja ne živi dlje od spremenljivke, ki jo referencira. 

\begin{stgcode}
-- Glavna funkcija
main = THUNK(
	let a = THUNK(12) in
		&a
)
\end{stgcode}

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
	\tikzset{
		every node/.append style={text width=1.4cm,execute at begin node=\setlength{\baselineskip}{1em},font=\footnotesize},
		block/.style={draw,rectangle,text width=2cm,align=center,minimum height=1cm,minimum width=2cm},
	}
	
	\node[block] (parser) {\textbf{Razčlen\-jevanje}};
	
	\node[coordinate, left=0.5cm of parser.west] (levo-od-parser) {};
	
	\node[block,right=1cm of parser] (borrow-checker) {Analiza izposoj};
	\node[block, above=0.5cm of borrow-checker] (name-resolution) {\textbf{Raz\-re\-še\-van\-je imen}};
	\node[block, below=0.5cm of borrow-checker] (move-checker) {Analiza premikov};
	\node[block, right=1cm of borrow-checker] (interpreter) {\textbf{Abstraktni stroj STG'}};
	
	\node[coordinate, right=0.5cm of interpreter.east] (desno-od-interpreter) {};
	
	% Input arrow
	\draw[->] (levo-od-parser) -- (parser) node[above, pos=-0.25,align=center] {\scriptsize tok\\znakov};
	
	% Output arrow
	\draw[->] (interpreter) -- (desno-od-interpreter) node[above,pos=1.25,align=center] {\scriptsize rezultat};
	
	% Parser -> name resolution arrow
	\node[coordinate, right=0.3cm of parser.east] (desno-od-parser) {};
	\node[coordinate] at (desno-od-parser |- name-resolution) (levo-od-name-resolution) {};	
	\draw[->] (parser) -- (desno-od-parser) -- node[align=center,sloped,anchor=center,above,pos=0.75] {\scriptsize STG} (levo-od-name-resolution) -- (name-resolution);
	
	% Move checker -> abstract STG machine arrow
	\node[coordinate, left=0.3 of interpreter.west] (levo-od-interpreter) {};
	\node[coordinate] at (move-checker -| levo-od-interpreter) (desno-od-move-checker) {};
	\draw[->] (move-checker.east) -- (desno-od-move-checker) -- node[align=center,sloped,anchor=center,below,pos=0.25] {\scriptsize STG'} (levo-od-interpreter) -- (interpreter);
	
	% 
	\draw[->] (name-resolution) -- node[pos=0.5,right] {\scriptsize STG} (borrow-checker);
	\draw[->] (borrow-checker) -- node[pos=0.5,right] {\scriptsize STG'} (move-checker);
	
	% Oznake za semantično analizo
	\node[coordinate, above=0.4 of name-resolution.north] (top) {};
	\node[coordinate, below=0.4 of move-checker.south] (bottom) {};
	
	\node[coordinate, left=0.5 of borrow-checker.west] (semanticna-analiza-levo) {};
	\node[coordinate, right=0.5 of borrow-checker.east] (semanticna-analiza-desno) {};
	
	\node[coordinate] at (semanticna-analiza-levo |- top) (semanticna-analiza-levo-zgoraj) {};
	\node[coordinate] at (semanticna-analiza-levo |- bottom) (semanticna-analiza-levo-spodaj) {};
	
	\node[coordinate] at (semanticna-analiza-desno |- top) (semanticna-analiza-desno-zgoraj) {};
	\node[coordinate] at (semanticna-analiza-desno |- bottom) (semanticna-analiza-desno-spodaj) {};
	
	\draw[-,dashed] (semanticna-analiza-levo-zgoraj) -- (semanticna-analiza-levo-spodaj) -- (semanticna-analiza-desno-spodaj) -- (semanticna-analiza-desno-zgoraj) -- (semanticna-analiza-levo-zgoraj);
	
	\path (semanticna-analiza-levo-zgoraj) -- node[above=0.1,align=center,text width=3cm] {Semantična analiza} (semanticna-analiza-desno-zgoraj);
	
	\end{tikzpicture}
	\caption{Faze implementirane prevajalnika}
	\label{fig:shema-implementacije}
\end{figure}

\section{Analiza izposoj}

\section{Analiza premikov}

\chapter{Rezultati}
\label{ch:rezultati}

% Za potrebe naše magistrske naloge bomo v izbranem programskem jeziku implementirali simulator STG stroja. V programskem jeziku STG bomo napisali zbirko programov, s pomočjo katerih bomo testirali uspešnost implementirane metode. Merili bomo količino dodeljenega pomnilnika in količino sproščenega pomnilnika in skušali ugotoviti, ali je ves pomnilnik pravočasno sproščen. Cilj magistrskega dela ni izdelava učinkovite implementacije čiščenja pomnilnika, temveč skušati ugotoviti, kakšne spremembe in analize je potrebno dodati v STG stroj, da bo lahko uporabljal princip lastništva namesto čistilca pomnilnika.

%\chapter{Zaključek}
%\label{ch:zakljucek}

%----------------------------------------------------------------
% SLO: bibliografija
% ENG: bibliography
%----------------------------------------------------------------
\bibliographystyle{elsarticle-num}
\bibliography{bibliography}

\end{document}
